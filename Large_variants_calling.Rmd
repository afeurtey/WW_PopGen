---
title: "Variants calling: CNV, PAV, and SV"
output:
  html_document:
    df_print: paged
    code_folding: hide
---


```{r setup}
#Packages
library(tidyverse)
library(cowplot)

#Files and directories 
dir_name = "/data2/alice/WW_project/"
metadata_dir=paste0(dir_name, "Metadata/")
list_dir="/home/alice/WW_PopGen/Keep_lists_samples/"


#Analysis directories
#____________________
data_dir=paste0(dir_name, "0_Data/")
assemb_dir = paste0(data_dir, "2_Denovo_assemblies/")
mito_gen_dir=paste0(data_dir, "4_Mitochondrial_genome/")
  mito_blast=paste0(mito_gen_dir, "0_Mito_blast/")
  mito_fasta=paste0(mito_gen_dir, "1_Mitochondrial_fastas/")
  
VAR_dir = paste0(dir_name, "1_Variant_calling/")
  depth_per_window_dir = paste0(VAR_dir, "1_Depth_per_window/")
  depth_per_gene_dir = paste0(VAR_dir, "2_Depth_per_gene/")
  vcf_dir = paste0(VAR_dir, "4_Joint_calling/")
  mito_SV = paste0(VAR_dir, "6_Mito_SV/")
PopStr_dir = paste0(dir_name, "2_Population_structure/")
mito_PS_dir = paste0(PopStr_dir, "1_Mitochondrial_genome/")


# Important files
#________________
Zt_list = read_tsv("/home/alice/WW_PopGen/Keep_lists_samples/Ztritici_global_March2021.genotyped.good_samples.args", 
                   col_names = "ID_file")
metadata_cols = read_tsv("/home/alice/WW_PopGen/Keep_lists_samples/Main_table_from_SQL_Feb_2020_Description.tab", 
                         col_names = F) %>% pull()
metadata_file= read_tsv("/home/alice/WW_PopGen/Keep_lists_samples/Main_table_from_SQL_Feb_2020_with_collection.tab",
                        col_names = metadata_cols) 
mito_PS_dir = "/data2/alice/WW_project/0_Data/"


Sys.setenv(DATADIR=data_dir)
Sys.setenv(DEPTHGENEDIR=depth_per_gene_dir)

knitr::opts_chunk$set(message = F)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(results = T)
```

#Depth per chromosome
I have run the depth per window for all chromosomes. From this data, I can extract summaries per chromosome per sample, per sample over the whole genome or per sample for the core chromosomes only.
```{bash summary depth, eval = F}
list_file=$(ls -1 ${WINDEPTH}*.depth_per_window.q30.txt )

#Per sample per chromosome
echo -e "Sample\tCHROM\tMedian\tMean" > ${WINDEPTH}Depth_per_chromosome_summary.q30.txt
for p in $list_file ; 
do 
  sed "s/:/\t/g" $p | ~/Software/bedtools groupby -g 1,2 -o median,mean -c 5; 
done >> ${WINDEPTH}Depth_per_chromosome_summary.q30.txt

#Per sample
echo -e "Sample\tMedian\tMean" > ${WINDEPTH}Depth_per_sample_summary.q30.txt
for p in $list_file ; 
do 
  sed "s/:/\t/g" $p | ~/Software/bedtools groupby -g 1 -o median,mean -c 5; 
done >> ${WINDEPTH}Depth_per_sample_summary.q30.txt

#Per sample on core chromosomes
echo -e "Sample\tMedian\tMean" > ${WINDEPTH}Depth_per_sample_core_chr_summary.q30.txt
for p in $list_file ; 
do 
  sed "s/:/\t/g" $p | \
    awk 'BEGIN {FS = "\t"; OFS = "\t"} $2 < 14 {print}' | \
    ~/Software/bedtools groupby -g 1 -o median,mean -c 5 

done >>  ${WINDEPTH}Depth_per_sample_core_chr_summary.q30.txt

```

Such summaries per chromosomes are very useful to visualize if some samples have multiple copies of a chromosomes or the presence/absence of chromosomes in particular for the accessory chromosomes.
```{r CHR depth }

# Reading in the summarized data
core_depth = read_tsv(paste0(depth_per_window_dir, "Depth_per_sample_core_chr_summary.q30.txt")) %>%
  mutate(Median_core = Median) %>%
  inner_join(., Zt_list, by = c("Sample" = "ID_file"))
  
chrom_depth = read_tsv(paste0(depth_per_window_dir, "Depth_per_chromosome_summary.q30.txt")) %>%
  left_join(., core_depth %>% select(Sample, Median_core)) %>%
  mutate(Relative_depth = as.numeric(Median)/as.numeric(Median_core)) %>%
  inner_join(., Zt_list,  by = c("Sample" = "ID_file"))


# Heatmap of the depth per chromosome
heatmap_depth = chrom_depth %>%
  filter(CHROM != "mt") %>%
  ggplot(aes(x = as.numeric(CHROM), y=Sample, fill=Relative_depth)) +
  geom_tile() + scale_fill_gradient2(low="white", high = "#479DAE") +
  geom_vline(xintercept = 13.5, linetype = "longdash", colour = "gray20") +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank(), axis.ticks.y=element_blank()) +
  labs(fill = "Depth", x= "Chromosome") + xlim(c(0.5, 21.5))


ggplot(data = chrom_depth, aes(Relative_depth)) +
  geom_density(col = "#16697a", fill = "#16697a", alpha =0.4) +
  facet_wrap(vars(as.numeric(CHROM)), scales = "free") +
  theme_classic() +
  geom_vline(xintercept = 0.2, col = "#ffa62b")

# Estimation of low and high depth chromosomes
# (as proxy for present in 0 or multiple copies)
Lthres = 0.20
Hthres = 1.50
depth = chrom_depth %>%
  filter(CHROM != "mt") %>%
  dplyr::mutate(Depth_is = ifelse(Relative_depth > Hthres, "High",ifelse(Relative_depth < Lthres, "Low", "Normal")))

# Barplot
bar_Ndepth_per_CHR =ggplot(depth, aes(x = as.numeric(CHROM), fill = Depth_is)) +
  geom_bar(stat = "count") +
  scale_fill_manual(values = c("#16697a", "#82c0cc", "#EDE7E3")) +
    theme_light()+
    labs(x= "Chromosome", y = "Number of isolates")

# Lollipop plots
##For low normalized depth values
temp = depth %>%
  filter(Depth_is == "Low") %>%
  dplyr::group_by(CHROM) %>%
  dplyr::count()

lollow = ggplot(temp, aes(x = as.character(CHROM), y = n)) +
    geom_segment( aes(x=as.character(CHROM), xend=as.character(CHROM), y=0, yend=max(temp$n)),
                  color="grey80", size = 1) +
    geom_segment( aes(x=as.character(CHROM), xend=as.character(CHROM), y=0, yend=n),
                  color="grey20", size = 1) +
    geom_point( color="#82c0cc", size=4)  +
    geom_text(aes( label = n,
                     y= n), stat= "identity",
              hjust = -0.5, vjust = -0.2) +
    theme_light() +
    theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10)
    ) +
    ylim(c(0,max(temp$n)+ max(temp$n)*0.1)) +
    labs( x= "Chromosome", y = "Number of isolates without chromosome") +
    coord_flip()


# Gathering all 3 plots into a single figure
bottom_row <- cowplot::plot_grid(bar_Ndepth_per_CHR + theme(legend.position = "bottom"), lollow, 
                                 labels = c('B', 'C'), label_size = 12, ncol = 2)

cowplot::plot_grid(heatmap_depth, bottom_row, labels = c('A', ''), label_size = 12, ncol = 1)


```


```{r accCHR depth continent}
metadata_file %>% dplyr::select(Sample = ID_file, Continent) %>%
  filter(Continent != "\\N") %>%
  filter(Continent != "Asia") %>%
  inner_join(chrom_depth) %>%
  filter(CHROM != "mt") %>%
  filter(as.numeric(CHROM) > 13) %>%
  dplyr::mutate(Depth_is = ifelse(Relative_depth > Hthres, "High",ifelse(Relative_depth < Lthres, "Low", "Normal"))) %>%
  ggplot(aes(x = Continent, fill = Depth_is)) + 
    geom_bar(position = "fill") +
  theme_bw() + 
  facet_wrap(vars(CHROM), scales = "free")+
  scale_fill_manual(values = c("#16697a", "#82c0cc", "#EDE7E3")) 
```



# Depth per window and GC bias
I have used the bedtools nuc option to estimate the GC content per 1kb-window for the whole reference IPO323 genome 
```{r depth ref}
GC_per_window = read_tsv(paste0(data_dir, "Zymoseptoria_tritici.MG2.dna.toplevel.mt+.1kb_windows.nuc_GC.tab")) %>%
  mutate(GC = round(`5_pct_gc`, 2)) %>%
  filter( !is.na(`#1_usercol`))

temp = GC_per_window %>%
  filter(`#1_usercol` < 14)  %>%
  dplyr::select(CHROM = `#1_usercol`, Win_start = `2_usercol`, Win_stop = `3_usercol`, GC) %>%
  group_by(GC) %>%
  count() 

# Histogram of GC values
xint = median(GC_per_window$GC)
temp %>%
  ggplot(aes(x = GC, y = n, fill = n > 40)) +
    geom_bar(stat = "identity") +
    theme_light() +
  scale_fill_manual(values =c( "#82c0cc", "#EDE7E3"))+
  geom_vline(xintercept = xint, col = "#82c0cc") +
  annotate("text", label = paste0("Median GC is ", xint), 
           x = xint - xint*0.2, y = 5200, 
           size = 4, colour = "#82c0cc", fontface = "bold")

GC_avail = temp %>% filter(n > 40) %>% dplyr::select(GC) %>% pull()

random_GC_windows = GC_per_window %>%
  dplyr::select(CHROM = `#1_usercol`, Win_start = `2_usercol`, Win_stop = `3_usercol`, GC) %>%
  filter(GC %in% GC_avail)%>%
  group_by(GC) %>%
  sample_n(40) %>%
  mutate(CHROM = as.character(CHROM), 
         Win_start = as.character(Win_start), 
         Win_stop = as.character(Win_stop))
  
```
The distribution of GC is slightly skewed in the GC-rich side, with a median above 0.5. However, there is an AT-rich fat tail, or even a bimodal distribution. These windows are most probably containing RIP-affected repeated regions.

From there, we need to know if the different collections present GC bias in their sequencing. We expect a batch effect in the sequencing here since we have data coming from a lot of different years and labs (and because batch effect happens in general).
```{r Depth per win,  eval = F}

files <- list.files(depth_per_window_dir, pattern = "depth_per_window.q30.txt$", full.names = T)

depth_per_win = files %>%
  map_dfr(~read_tsv(., col_names = c("temp", "Depth")) %>%
                                            separate(col = temp, into = c("ID_file", "CHROM", "Win_start", "Win_stop"),
                                                     sep = ":") %>%
                                             inner_join(., random_GC_windows)) %>%
  left_join(., Zt_list)

write_tsv(depth_per_win, paste0(depth_per_window_dir, "Depth_for_GC_bias.txt"))
```


```{r GC bias}
depth_per_win = read_tsv(paste0(depth_per_window_dir, "Depth_for_GC_bias.txt"))

scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}


GC_coverage = depth_per_win %>%
  filter(Depth > 0) %>%
  group_by(ID_file) %>%
  dplyr::mutate(scaled_depth = scale_this(Depth)) %>%
  filter(!is.na(scaled_depth)) 


#GC bias estimation
getAlpha<-function(i){
  #print(i)
  temp = GC_coverage %>%
    filter(ID_file == i) #%>%
    #mutate(log_depth = log(Depth))
  
  if (nrow(temp) < 10) {
    return(NA)} else {
  linearMod <- lm(scaled_depth ~ GC, data=temp)  # build linear regression model on full data
  alpha = linearMod$coefficients["GC"]
  return (alpha)}}
v_getAlpha <- Vectorize(getAlpha)


GC_bias = GC_coverage %>%
  dplyr::select(ID_file) %>%
  distinct() %>%
  dplyr::mutate(GC_bias_slope = v_getAlpha(ID_file)) %>%
  left_join(., metadata_file %>% select(ID_file, Collection, Continent, Country, Region, 
                                        Sampling_Date, Latitude, Longitude))

write_tsv(GC_bias, paste0(depth_per_window_dir, "GC_bias_per_sample.txt"))


ggplot(GC_bias, aes(GC_bias_slope)) +
  geom_density() +
  theme_bw()


#GC bias illustration
GC_coverage %>%
  filter(ID_file %in% sample(GC_coverage$ID_file, 15)) %>%
  ggplot(aes(GC, Depth)) +
    geom_point(col = "grey", alpha = 0.4) + 
    scale_fill_continuous(type = "viridis") +
    theme_bw() + facet_wrap(~ID_file, scale = "free") +
    geom_smooth(method = "lm", se = FALSE,
                color = "goldenrod", size= 0.7) +
    labs(x = "GC percent per window",
         y = "Depth per window",
         title = "Illustration of the GC bias",
         subtitle = "I use the slope of a linear model to infer the GC bias.")

#GC bias per collection
temp = GC_bias %>%
  filter(Collection != "\\N") %>%
  group_by(Collection) %>%
  count() %>%
  filter(n >= 20) 

GC_bias_violins = inner_join(temp, GC_bias) %>%
  group_by(Collection) %>%
  mutate(Median = median(GC_bias_slope)) %>%
 ggplot(., aes(x = reorder(Collection, Median), y = GC_bias_slope, fill = reorder(Collection, Median))) +
  geom_violin(alpha = .7) +
  theme_bw()  +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1),
        plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  labs(x = "Collection", y = "GC bias estimate")
GC_bias_violins

```
It is very clear that we do have a batch effect but also that some datasets are very, very biased. The older Hartmann data (also called Qst population) in particular is strongly biased.



# Depth per gene
Aside from the depth per window, I have also estimated the depth of coverage per gene. I want to infer some gene presence/absence based on the depth so I need to normalize the depth. I have tried to normalize simply based on the depth over the core chromosomes in general, but this resulted in a median normalized depth per gene at 1.1 instead of 1 as expected. This is probably due to lower coverage in intergenic regions (in particular repeated regions that might be more suspectible to being deleted in some strains). The overall coverage for the chromosome would thus be lower than the coverage for the genes of the same chromosome. 

I have chosen to normalize using the median depth of genes for the core chromosomes. This resulted in a normalized depth with a median around one as shown with a sample of 4 isolates. 
```{r visual sample}
files <- list.files(depth_per_gene_dir, pattern = "depth_per_gene.q30.txt$", full.names = T)

depth_per_gene = sample(files, size = 4)  %>%
  map_dfr(~read_tsv(., col_names = c("temp", "Depth")) %>%
               separate(col = temp, into = c("Sample", "CHROM", "Gene"), sep = ":")) %>%
  left_join(., metadata_file, c("Sample" = "ID_file"))

temp = depth_per_gene %>%
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  filter(as.numeric(CHROM) < 14) %>%
  group_by(Sample) %>%
  summarize(Median_core = median(Depth))

depth_per_gene %>%
  inner_join(., temp) %>%
  mutate(Norm_median_depth = Depth / Median_core) %>% 
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  ggplot(aes(x = Norm_median_depth, fill = Sample, col = Sample)) +
  geom_density(alpha = 0.4) +
  geom_vline(xintercept = 1, col = "black", linetype = "dashed") +
  facet_wrap(vars(as.numeric(CHROM)), scales ="free") +
  theme_bw()+ 
  labs(title = "Normalized with the depth of the core chromosomes genes",
       x = "Normalized depth of coverage per gene")
```
Once I am confident that the normalization I am using is appropriate, I do this for all genes.
```{r norm gene depth, results = F, warning=F, eval = F}
files <- list.files(depth_per_gene_dir, pattern = "depth_per_gene.q30.txt$", full.names = T)

depth_per_gene = files %>%
  map_dfr(~read_tsv(., col_names = c("temp", "Depth")) %>%
               separate(col = temp, into = c("Sample", "CHROM", "Gene"), sep = ":")) 

temp = depth_per_gene %>%
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  filter(as.numeric(CHROM) < 14) %>%
  group_by(Sample) %>%
  summarize(Median_core = median(Depth))

depth_per_gene = depth_per_gene %>%
  inner_join(., temp) %>%
  mutate(Norm_median_depth = round(Depth / Median_core, 2)) %>%
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  separate(col = Gene, into = c("ID", "Name"), sep = ";") %>%
  select(-ID) %>%
  mutate(Name = str_replace(Name, "Name=", ""))

write_tsv(depth_per_gene, paste0(depth_per_gene_dir, "Depth_per_genes_normalized.txt"))

```


# Depth for resequencing pairs

```{r GC bias per pair}

depth_per_gene = read_tsv(paste0(depth_per_gene_dir, "Depth_per_genes_normalized.txt"))
repeat_seq = read_delim(paste0(list_dir, "Repeat_sequencing.txt"), col_names = c("Seq1", "Seq2"), delim = " ") %>%
  mutate(Pair = paste0("Pair_", c(1:length(Seq1)))) %>% 
  pivot_longer(-Pair, names_to = "temp", values_to = "ID_file") %>% 
  #dplyr::select(-temp) %>%
  left_join(., GC_bias) %>%
  mutate(Collection = ifelse(is.na(Collection), "ETHZ_2020", Collection))

repeat_collec = unique(repeat_seq$Collection)

depth_per_gene %>% 
  select(Sample, Median_core) %>%
  distinct() %>%
  inner_join(., GC_bias, by = c("Sample" = "ID_file")) %>%
  filter(Collection %in% repeat_collec) %>%
  group_by(Collection) %>%
  mutate(Median = median(GC_bias_slope)) %>%
 ggplot(.) +
  geom_violin(aes(x = reorder(Collection, Median), y = GC_bias_slope), alpha = .7) +
  theme_bw()  +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1),
        plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  labs(x = "Collection", y = "GC bias estimate") +
  geom_point(data = repeat_seq, aes(col = Pair, x = Collection, y = GC_bias_slope))


temp2 = repeat_seq %>% 
  dplyr::select(Pair, temp, GC_bias_slope) %>% 
  pivot_wider(names_from = temp, values_from = GC_bias_slope)

pair_GC_plot = ggplot(data = repeat_seq, aes(y = Pair, x = GC_bias_slope)) + 
  geom_point(aes(col = Collection)) + 
  geom_segment(data = temp2, aes(y = Pair, yend = Pair, x = Seq1, xend = Seq2)) + 
  theme_bw() +
  labs(x = "GC bias estimation", y = element_blank())
  
```

```{r TE vs GCbias}
TE = read_delim("/data2/alice/WW_project/4_TE_RIP/0_RIP_estimation/Nb_reads_repeat_sequencing.txt", delim = " ") %>%
  mutate(Percent_TE_reads = 100*Te_aligned_reads/Genome_aligned_reads) %>%
  inner_join(repeat_seq)

#Plot TE content
seg_TE = TE %>% dplyr::select(Pair, temp, Percent_TE_reads) %>% pivot_wider(names_from = temp, values_from = Percent_TE_reads)
pair_TE_plot = ggplot(data = TE, aes(y = Pair, x = Percent_TE_reads)) + 
  geom_point(aes(col = Collection)) + 
  geom_segment(data = seg_TE, aes(y = Pair, yend = Pair, x = Seq1, xend = Seq2)) + 
  theme_bw() +
  labs(x = "TE content estimation", y = element_blank())

#Get legend and put plots together
legend = get_legend(pair_GC_plot + theme(legend.position = "bottom"))

row_plot = cowplot::plot_grid(pair_GC_plot + theme(legend.position = "none"),
                              pair_TE_plot + theme(legend.position = "none"),
                              ncol = 2, labels = c("A", "B"))

cowplot::plot_grid(row_plot, legend, rel_heights = c(10, 1), ncol = 1)
```


```{r CNV comparison}

genes_pairs = paste0(depth_per_gene_dir, unique(repeat_seq$ID_file), ".depth_per_gene.q30.txt") %>%
  map_dfr(~read_tsv(., col_names = c("temp", "Depth")) %>%
               separate(col = temp, into = c("ID_file", "CHROM", "Gene"), sep = ":")) 


temp = genes_pairs %>%
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  filter(as.numeric(CHROM) < 14) %>%
  group_by(ID_file) %>%
  summarize(Median_core = median(Depth))

genes_pairs = genes_pairs %>%
  inner_join(., temp) %>%
  #mutate(Norm_median_depth = round(Depth / Median_core)) %>%
  mutate(Norm_median_depth = ifelse(Depth / Median_core < 0.25, 0, 
                                    ifelse(Depth / Median_core > 1.75, 2, 1))) %>%
  filter(str_detect(Gene, "_TU_"))  %>% 
  filter( !str_detect(Gene, "Parent")) %>%
  separate(col = Gene, into = c("ID", "Name"), sep = ";") %>%
  select(-ID) %>%
  mutate(Name = str_replace(Name, "Name=", "")) %>% 
  full_join(., repeat_seq)

temp = genes_pairs %>%
  dplyr::select(Pair, temp, Name, Norm_median_depth) %>%
  pivot_wider(names_from = temp, values_from = Norm_median_depth) %>%
  mutate(diff = abs(Seq1 - Seq2))

p1 = temp %>% 
  group_by(Pair) %>%
  count(diff) %>%
  pivot_wider(names_from = diff, values_from = n) %>% 
   ggplot(aes(x = Pair, y = `1`, fill = Pair)) + 
   geom_bar(stat = "identity") + 
   theme_bw() +
   labs(y = "Number of genes", x = "",
        subtitle = "Genes with a different CNV value per pair") 


p2 = temp %>% 
   filter(diff > 0) %>% 
   group_by(Name) %>% 
   count() %>% 
   ggplot(aes(n)) + 
   geom_histogram(bins = 6) + 
   theme_bw() +
   labs(y = "Number of genes", x = "Number of pairs",
        subtitle = "Genes with a difference CNV value shared between pairs") 
 
row1 = cowplot::plot_grid(p1 + theme(legend.position = "none"), p2, ncol = 2, labels = c("A", "B"))


p3 = genes_pairs %>%
  filter(Norm_median_depth != 1) %>%
  group_by(ID_file, Norm_median_depth) %>%
  count()%>% 
   ggplot(aes(x = ID_file, y = n, fill = as.character(Norm_median_depth))) + 
   geom_bar(stat = "identity") + 
   theme_bw() +
  theme(axis.text.x = element_text(angle = 25, hjust = 1, vjust = 1),
        plot.margin = unit(c(0.5, 0.5, 0.5, 1.5), "cm")) +
  labs(y = "Number of genes", x = element_blank(),
       fill = "CNV")
  
cowplot::plot_grid(row1, p3, ncol =1, labels = c("", "C"))
```
```{r}
# head -n1 /data2/alice/WW_project/1_Variant_calling/2_Depth_per_gene/global_IPO-CNV.seg.gene.table \
#    > /data2/alice/WW_project/1_Variant_calling/2_Depth_per_gene/global_IPO-CNV.seg.gene.reseq_only.tab
# grep -f WW_PopGen/Keep_lists_samples/Repeat_sequencing.args \
#    /data2/alice/WW_project/1_Variant_calling/2_Depth_per_gene/global_IPO-CNV.seg.gene.table  | cut -f 2- \
#     >> /data2/alice/WW_project/1_Variant_calling/2_Depth_per_gene/global_IPO-CNV.seg.gene.reseq_only.tab

genes_pairs_Sabina = read_csv(paste0(depth_per_gene_dir, "Sabina_gcnv_event.reseq_only.csv"))  %>% 
  full_join(., repeat_seq, by = c("sample" = "ID_file"))

temp = genes_pairs_Sabina %>%
  dplyr::select(Pair, temp, ref_gene, event) %>%
  filter(temp != "NA") %>%
  distinct() %>%
  pivot_wider(names_from = temp, values_from = event) %>%
  mutate(Comparison = ifelse( Seq1 == Seq2, "OK", "Different"))


p1 = temp %>% 
  filter(Comparison == "Different") %>%
  group_by(Pair) %>%
  count() %>% 
   ggplot(aes(x = Pair, y = n, fill = Pair)) + 
   geom_bar(stat = "identity") + 
   theme_bw() +
   labs(y = "Number of genes", x = "",
        subtitle = "Genes with a different CNV value per pair") 


p2 = left_join(genes_pairs_Sabina, temp) %>%
  filter(!is.na(Comparison)) %>%
  filter(Seq1 != "P" | Seq2 != "P") %>%
  ggplot(aes(x = Pair, y = QS, fill = Comparison, color = Comparison)) +
    geom_violin() +
  scale_fill_manual(values =c( "#82c0cc", "#EDE7E3")) +
  scale_color_manual(values =c( "#82c0cc", "#EDE7E3")) +
  theme_cowplot() +
  labs(x = element_blank(), y = "Variants quality") + 
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12))

p3 = left_join(genes_pairs_Sabina, temp) %>%
  filter(!is.na(Comparison)) %>%
  ggplot(aes(x = Pair, y = QS, fill = Comparison, color = Comparison)) +
    geom_violin() +
  scale_fill_manual(values =c( "#82c0cc", "#EDE7E3")) +
  scale_color_manual(values =c( "#82c0cc", "#EDE7E3")) +
  theme_cowplot() +
  labs(x = element_blank(), y = "All genes quality") + 
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12))

legend_b = get_legend(p3 + theme(legend.position = "bottom"))

col2 = cowplot::plot_grid(p2 + theme(legend.position = "none"), 
                          p3 + theme(legend.position = "none"), 
                          legend_b, 
                          ncol = 1, rel_heights = c(1, 1, 0.4))
cowplot::plot_grid(p1+ theme(legend.position = "none"), col2, ncol = 2)
```

```{r CNV filtering}
threshold_QS = 1000
Sys.setenv(threshold_QS=threshold_QS)
  
filtered_comparison = left_join(genes_pairs_Sabina, temp) %>%
  filter(!is.na(Comparison)) %>%
  filter(Seq1 != "P" | Seq2 != "P") 

filtered_comparison %>%
  ggplot(aes(x = Comparison, y = QS, fill = Comparison)) +
    geom_violin() +
    geom_boxplot(width = 0.03, fill = "white") +
    scale_fill_manual(values =c( "#82c0cc", "#EDE7E3")) +
    theme_cowplot() +
    labs(x = element_blank(), y = "Variants quality") + 
    theme(axis.text = element_text(size = 10),
          axis.title = element_text(size = 12))

filtered_comparison %>%
  ggplot(aes(x = QS, fill = Comparison)) +
    geom_density(alpha = 0.6) +
    scale_fill_manual(values =c( "#82c0cc", "#EDE7E3")) +
    theme_cowplot() +
    labs(x = element_blank(), y = "Variants quality") + 
    theme(axis.text = element_text(size = 10),
          axis.title = element_text(size = 12)) +
    geom_vline(xintercept = threshold_QS)


summary_filtered = filtered_comparison %>%
  group_by(Comparison) %>%
  count(QS > threshold_QS) 

summary_filtered %>%
  ggplot(aes(x = Comparison, y = n, fill = `QS > threshold_QS`)) +
    geom_bar(stat = "identity") +
    theme_cowplot() +
    scale_fill_manual(values =c( "#EDE7E3", "#82c0cc" )) +
    geom_label(data = summary_filtered %>% filter(`QS > threshold_QS`),
               mapping = aes(x = Comparison, y = n + 1000 , label = n))
  
```

```{bash}
 awk -v threshold=${threshold_QS} 'BEGIN {FS = ","; OFS = "\t"} $9 > threshold {print $1,($2 + $3)/2,$4,$5,$15 } ' \
    ${DEPTHGENEDIR}Sabina_gcnv_event.csv \
    > ${DEPTHGENEDIR}Sabina_gcnv_event.filtered.tsv
```


## CNV variants
```{r}
  
#temp = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
#                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele"), skip = 1) %>%
#  pivot_wider(names_from = Sample, values_from = Allele, values_fill = ".")

variant_list = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele"), skip = 1) %>%
  filter(Sample %in% Zt_list$ID_file) %>%
  mutate(POS = round(POS)) %>%
  group_by(CHROM, POS, Gene) %>%
  dplyr::count(Allele) %>%
  mutate(Nb_allele = n()) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, P, D, PD, PM), sum = sum(M, P, D, PD, PM)) 
write_tsv(variant_list, 
          file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.per_gene.tsv"))


temp = depth_per_gene %>% filter(Sample %in% Zt_list$ID_file) %>% 
  mutate(Norm_median_depth = as.numeric(Norm_median_depth)) %>%
  mutate(Allele = ifelse(Norm_median_depth < 0.25, "D", 
                                                ifelse(Norm_median_depth > 1.75, "M", "P"))) %>%
 group_by(CHROM, Name) %>% dplyr::count(Allele) %>% mutate(Nb_allele = n()) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, P, D), sum = sum(M, P, D)) 

table(temp$Nb_allele)
table(variant_list$Nb_allele)
bind_rows(temp %>% mutate(Method = "Alice"), variant_list %>% mutate(Method = "Sabina"))  %>%
  filter(Nb_allele > 1) %>% 
  ggplot(aes(x = max, fill = Method, col = Method)) + 
     geom_density(alpha = 0.4) + 
     theme_bw()

  


Alice_CNV_per_sample = depth_per_gene %>% filter(Sample %in% Zt_list$ID_file) %>% 
  mutate(Norm_median_depth = as.numeric(Norm_median_depth)) %>%
  mutate(Allele = ifelse(Norm_median_depth < 0.25, "D", 
                                                ifelse(Norm_median_depth > 1.25, "M", "P"))) %>%
  filter(CHROM < 14) %>%
  group_by(Sample) %>% dplyr::count(Allele) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, D), sum = sum(M, D)) %>% 
  mutate(Method = "Alice")

Sabina_CNV_per_sample = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele"), skip = 1) %>%
  filter(Sample %in% Zt_list$ID_file) %>%
  filter(CHROM < 14) %>%
  mutate(POS = round(POS)) %>%
  group_by(Sample) %>% dplyr::count(Allele) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, D, PD, PM), sum = sum(M, D, PD, PM)) %>% 
  mutate(Method = "Sabina")

write_tsv(Sabina_CNV_per_sample, 
          file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.core_chr.per_sample.tsv"))

bind_rows(Alice_CNV_per_sample, Sabina_CNV_per_sample) %>%
  ggplot(aes(x = sum, col = Method, fill = Method)) +
  geom_density(alpha =.4) +
  theme_bw()

full_join(Alice_CNV_per_sample %>% dplyr::select(Sample, variant_Alice = sum),
          Sabina_CNV_per_sample %>% dplyr::select(Sample, variant_Sabina = sum)) %>%
  ggplot(aes(x = variant_Alice, y = variant_Sabina)) +
    geom_point() +
    theme_bw() +
      geom_abline(intercept = 0, slope = 1)

bind_rows(Alice_CNV_per_sample, Sabina_CNV_per_sample) %>% dplyr::select(-sum, -max, -P) %>% pivot_longer(-c(Sample, Method), names_to = "Variant_type", values_to = "Count") %>% ggplot(aes(fill = Method, col = Method, x = Variant_type, y = log2(Count))) + geom_violin(alpha = .4) + theme_bw()
```


```{r}
temp = variant_list %>%
  filter(sum > 1000) %>%
  filter(P != sum) 

temp %>% 
  dplyr::select(CHROM, D, sum) %>%
  mutate(prop = 100*D/sum) %>%
  ggplot(aes(reorder(as.character(CHROM), CHROM), prop)) +
    geom_boxplot() + 
    theme_bw()
  
temp = variant_list %>%
  dplyr::select(CHROM, POS, D, sum) %>%
  mutate(window = trunc(POS/10000)*10000, 
         prop = 100*D/sum, Core_accessory = ifelse(prop > 1, "accessory", "core")) %>%
  group_by(CHROM, window) %>%
  summarize(Nb_genes = n(), Mean_D_prop = mean(prop),
            Nb_accessory_genes = sum(Core_accessory == "accessory"),
            Prop_acc_genes = 100*Nb_accessory_genes/Nb_genes) 


filter(temp, Mean_D_prop > 0 & Prop_acc_genes > 0) %>%
  filter(CHROM < 14) %>%
ggplot(aes(Mean_D_prop, Prop_acc_genes)) +
  geom_point(alpha = .4) +
  theme_bw()

filter(temp, CHROM < 6) %>%
  ggplot(aes(x = window, y = Mean_D_prop)) + 
  geom_point() +
  theme_bw() +
  facet_grid(rows = vars(CHROM))

filter(temp, CHROM >= 6 & CHROM <= 13) %>%
  ggplot(aes(x = window, y = Prop_acc_genes)) + 
  geom_point() +
  theme_bw() +
  facet_grid(rows = vars(CHROM))

filter(temp, CHROM > 13) %>%
  ggplot(aes(x = window, y = Mean_D_prop)) + 
  geom_point() +
  theme_bw()+
  facet_grid(rows = vars(CHROM))


```

```{r}
PAV_Middle_East = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele"), skip = 1) %>%
  filter(Sample %in% Zt_list$ID_file) %>%
  inner_join(filter(metadata_file, Continent == "Middle East"), by = c("Sample" = "ID_file")) %>%
  select(CHROM, POS, Gene, Sample, Allele, Continent) %>%
  group_by(CHROM, POS, Gene) %>%
  dplyr::count(Allele) %>%
  mutate(Nb_allele = n()) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, P, D, PD, PM), sum = sum(M, P, D, PD, PM)) %>%
  dplyr::select(CHROM, POS, D, sum) %>%
  mutate(window = trunc(POS/10000)*10000, 
         prop = 100*D/sum, Core_accessory = ifelse(prop > 1, "accessory", "core")) %>%
  group_by(CHROM, window) %>%
  summarize(Nb_genes = n(), Mean_D_prop = mean(prop),
            Nb_accessory_genes = sum(Core_accessory == "accessory"),
            Prop_acc_genes = 100*Nb_accessory_genes/Nb_genes) 
PAV_Europe = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele"), skip = 1) %>%
  filter(Sample %in% Zt_list$ID_file) %>%
  inner_join(filter(metadata_file, Continent == "Europe"), by = c("Sample" = "ID_file")) %>%
  select(CHROM, POS, Gene, Sample, Allele, Continent) %>%
  group_by(CHROM, POS, Gene) %>%
  dplyr::count(Allele) %>%
  mutate(Nb_allele = n()) %>%
  pivot_wider(names_from = Allele, values_from = n, values_fill = 0) %>%
  mutate(max = max(M, P, D, PD, PM), sum = sum(M, P, D, PD, PM)) %>%
  dplyr::select(CHROM, POS, D, sum) %>%
  mutate(window = trunc(POS/10000)*10000, 
         prop = 100*D/sum, Core_accessory = ifelse(prop > 1, "accessory", "core")) %>%
  group_by(CHROM, window) %>%
  summarize(Nb_genes = n(), Mean_D_prop = mean(prop),
            Nb_accessory_genes = sum(Core_accessory == "accessory"),
            Prop_acc_genes = 100*Nb_accessory_genes/Nb_genes) 

full_join(PAV_Europe %>% dplyr::select(window, CHROM, D_prop_EU = Mean_D_prop), 
          PAV_Middle_East  %>% dplyr::select(window, D_prop_ME = Mean_D_prop)) %>%
  filter(D_prop_ME != 0 & D_prop_EU != 0) %>%
  ggplot(aes(x = D_prop_ME, y = D_prop_EU, col = as.factor(CHROM))) +
  geom_point() + 
  theme_bw()

filter(temp, CHROM < 6) %>%
  ggplot(aes(x = window, y = Mean_D_prop)) + 
  geom_point() +
  theme_bw() +
  facet_grid(rows = vars(CHROM))

filter(temp, CHROM > 13) %>%
  ggplot(aes(x = window, y = Mean_D_prop)) + 
  geom_point() +
  theme_bw() +
  facet_grid(rows = vars(CHROM))
```



## CNV per functional categories


```{r CNV effectors}

annot = read_tsv(paste0(data_dir, "Annotations_2018_genomes_for_publication.tab")) %>%
  filter(Sample == "Zt09")

effectors = annot %>% filter(Effector == "Effector") %>% select(Protein_ID) %>% pull()
  
effector_CNV = read_tsv(file = paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.tsv"),
                        col_names = c("CHROM", "POS", "Gene", "Sample", "Allele")) %>%
  mutate(Gene = str_replace(Gene, "TU", "chr")) %>%
  filter(Gene %in% effectors)
#  inner_join(., effectors, by = c("ref_gene" = "Protein_ID"))

ggplot(effector_CNV, aes(x = Gene, y = Sample, fill = Allele)) +
  geom_tile() +
  theme_cowplot() +
  theme()

temp = left_join(effector_CNV, metadata_file, by = c("Sample" = "ID_file")) %>%
  mutate(Sample = fct_reorder(Sample, Sampling_Date)) %>%
  mutate(Sample = fct_reorder(Sample, Country)) %>%
  mutate(Sample = fct_reorder(Sample, Continent)) 

heatmap_CNV = temp %>%
  ggplot(aes(x = Gene, y = Sample, fill = Allele)) +
  geom_tile() + 
  theme(axis.text.y = element_blank(), axis.ticks.y=element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x=element_blank()) +
  scale_fill_manual(values = c("gold", "darkred", "grey90", "yellow", "red"))

plot_continent = ggplot(data = temp, aes(x = 1, y=Sample, fill=Continent)) +
  geom_tile(aes(width = 2))  +
  theme_classic() +
  theme(axis.text.y = element_blank(), axis.ticks.y=element_blank(),
        legend.position="left",
        axis.text.x=element_text(colour="white")) +
  scale_fill_brewer(palette = "Dark2") +
    labs(y= "Isolate") 

plot_grid(plot_continent, heatmap_CNV, rel_widths = c(2, 5))

```
```{r}

CAZymes = annot %>% filter(CAZyme_family != "-") %>% select(Protein_ID) %>% pull()

CAZymes_CNV = read_tsv(paste0(depth_per_gene_dir, "Sabina_gcnv_event.filtered.simplified.tsv")) %>%
  filter(ref_gene %in% CAZymes)
#  inner_join(., effectors, by = c("ref_gene" = "Protein_ID"))

temp = left_join(CAZymes_CNV, metadata_file, by = c("sample" = "ID_file")) %>%
  ungroup() %>%
  #mutate(sample = fct_reorder(sample, Sampling_Date)) %>%
  #mutate(sample = fct_reorder(sample, Country)) %>%
  mutate(sample = fct_reorder(sample, Continent)) 

heatmap_CNV2 = temp %>%
  ggplot(aes(x = ref_gene, y = reorder(sample, Continent), fill = event)) +
  geom_tile() + 
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank()) 

plot_continent = ggplot(data = temp, aes(x = 1, y = reorder(sample, Continent), fill = reorder(sample, Continent))) +
  geom_tile(aes(width = 2))  +
  theme_classic() +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        legend.position ="left",
        axis.text.x = element_text(colour = "white")) +
  scale_fill_brewer(palette = "Dark2") +
    labs(y = "Isolate") 
plot_continent

plot_grid(plot_continent, heatmap_CNV2, rel_widths = c(2, 5))
```




# De novo assemblies
## Whole genome assembly statistics and filtering

```{bash, eval = F}

while read sample; 
do 
  echo $sample; 
  python ~/Common_scripts/Rename_fragments_in_fasta.py \
     --input /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}/scaffolds.fasta \
     -o /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}.fasta \
     --sample_name ${sample} --format spades --match_length_lines ; 
done < Keep_lists_samples/Assembled.sample_list.args
```

```{bash}
echo -e "Sample\tAssembly_type\tEstimate\tValue" > /data2/alice/WW_project/0_Data/2_Denovo_assemblies/Stats_filtered_assemblies.tab ;
while read sample; 
do 
  echo $sample; 
  python /home/alice/Common_scripts/Stats_from_fasta.py \
     /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}.fasta; 
  cat /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}.fasta_stats.txt | \
    awk -v sample=$sample 'BEGIN{FS = "\t"; OFS = "\t"} {print sample, "Filtered", $1, $2} ' >> \
    /data2/alice/WW_project/0_Data/2_Denovo_assemblies/Stats_filtered_assemblies.tab ; 
done < Keep_lists_samples/Assembled.sample_list.args

echo -e "Sample\tAssembly_type\tEstimate\tValue" > /data2/alice/WW_project/0_Data/2_Denovo_assemblies/Stats_raw_assemblies.tab
while read sample; 
do 
  echo $sample; 
  python /home/alice/Common_scripts/Stats_from_fasta.py \
    /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}/scaffolds.fasta; 
  cat /data2/alice/WW_project/0_Data/2_Denovo_assemblies/${sample}/scaffolds.fasta_stats.txt | \
    awk -v sample=$sample 'BEGIN{FS = "\t"; OFS = "\t"} {print sample, "Raw", $1, $2} ' >> \
    /data2/alice/WW_project/0_Data/2_Denovo_assemblies/Stats_raw_assemblies.tab ; 
done < Keep_lists_samples/Assembled.sample_list.args


```
```{r}
assemb_stats = bind_rows(read_tsv(paste0(assemb_dir, "Stats_raw_assemblies.tab")), 
                         read_tsv(paste0(assemb_dir, "Stats_filtered_assemblies.tab"))) %>%
  left_join(metadata_file, by = c("Sample" = "ID_file"))


assemb_stats %>%
  filter(!grepl("est contig", Estimate)) %>%
  ggplot(aes(x = Value, fill = Assembly_type, col = Assembly_type)) +
    geom_density(alpha = 0.6) +
    theme_bw() + 
    facet_wrap(vars(Estimate), scales = "free") +
    scale_fill_manual(values = c("#FF9F1C", "#2EC4B6"))  +
    scale_color_manual(values = c("#FF9F1C", "#2EC4B6")) 

assemb_stats  %>%
  filter(Assembly_type == "Filtered") %>%
  filter(!grepl("est contig", Estimate)) %>%
  group_by(Collection) %>%
  mutate(Nb_per_collec = n()/4) %>%
  filter(Nb_per_collec > 10) %>%
  filter(Assembly_type == "Filtered") %>%
  ggplot(aes(x = Collection, y = Value, fill = Collection)) +
    geom_violin() +
    theme_bw() + 
    facet_grid(rows = vars(Estimate), scales = "free") +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1)) +
  labs(x = element_blank())

assemb_stats %>%
  filter(Assembly_type == "Filtered") %>%
  filter(!grepl("est contig", Estimate)) %>%
  ggplot(aes(x = Value, fill = Assembly_type, col = Assembly_type)) +
    geom_density(alpha = 0.6) +
    theme_bw() + 
    facet_wrap(vars(Estimate), scales = "free") +
    scale_fill_manual(values = c("#FF9F1C", "#2EC4B6"))  +
    scale_color_manual(values = c("#FF9F1C", "#2EC4B6")) 
```

```{r de novo thresholds}

nb_contig_thr = 1600
temp = assemb_stats %>%
  filter(Assembly_type == "Filtered") %>%
  filter(Estimate == "Nb contigs") 
p1 = ggplot(temp, aes(x = Value, fill = Assembly_type, col = Assembly_type)) +
  geom_density(alpha = 0.6) + 
  geom_vline(xintercept = nb_contig_thr, col =  "#2EC4B6")  +
  theme_bw() + 
  labs(x = "Number of contigs",
       y = element_blank(), 
       subtitle = str_wrap(paste0(sum(temp$Value >= nb_contig_thr), 
                         " bad quality / ", 
                         sum(temp$Value < nb_contig_thr), " good quality"), 
                         width = 60)) +
    scale_fill_manual(values = c("#FF9F1C"))  +
    scale_color_manual(values = c("#FF9F1C"))

length_thr1 = 30000000
length_thr2 = 40000000
temp = assemb_stats %>%
  filter(Assembly_type == "Filtered") %>%
  filter(Estimate == "Cumulated length") 
p2 = ggplot(temp, aes(x = Value, fill = Assembly_type, col = Assembly_type)) +
    geom_density(alpha = 0.6) + 
    geom_vline(xintercept = length_thr1, col =  "#2EC4B6")  +
    geom_vline(xintercept = length_thr2, col =  "#2EC4B6")  +
  theme_bw() + 
  labs(x = "Length",
       y = element_blank(), 
       subtitle = str_wrap(paste0(sum(temp$Value <= length_thr1 | temp$Value  >= length_thr2), 
                         " bad quality / ", 
                         sum(temp$Value > length_thr1 &temp$Value  <= length_thr2), " good quality"), 
                         width = 60))+
    scale_fill_manual(values = c("#FF9F1C"))  +
    scale_color_manual(values = c("#FF9F1C"))



good_assemb = assemb_stats %>%
  filter(Assembly_type == "Filtered") %>%
  select(Sample, Estimate, Value) %>%
  pivot_wider(names_from = Estimate, values_from = Value) %>%
  filter(`Cumulated length` > length_thr1 & `Cumulated length`  < length_thr2) %>%
  filter(`Nb contigs` <= nb_contig_thr)

kept_assemblies = length(unique(good_assemb$Sample))

p3 = good_assemb %>%
  pivot_longer(-Sample, names_to = "Estimate", values_to = "Value") %>%
  ggplot(aes(x = Value)) +
    geom_density(alpha = 0.6, col = "#2EC4B6", fill = "#2EC4B6") +
    theme_bw() + 
    facet_wrap(vars(Estimate), scales = "free") + 
  labs(x = element_blank(), y = element_blank(), 
       subtitle = str_wrap(paste0("Combining the two filters retains ", kept_assemblies, 
                         " good quality assemblies."), 
                         width = 100))

top_row = cowplot::plot_grid(p1 + theme(legend.position = "none"),
                   p2 + theme(legend.position = "none"),
                   ncol = 2, labels = c("A", "B"))

cowplot::plot_grid(top_row, p3, ncol =1, labels = c("", "C"))

good_assemb %>%
  write_tsv(paste0(assemb_dir, "Good_assemblies_stats.tab"))
```


## Mitochondrial complete assemblies

```{bash mito blast, eval = F}

project_dir=/data2/alice/WW_project/
DATA_DIR=${project_dir}0_Data/
mito_gen_dir=${DATA_DIR}4_Mitochondrial_genome/
  mito_blast=${mito_gen_dir}0_Mito_blast/
pop_str_dir=${project_dir}2_Population_structure/
mito_PS_dir=${pop_str_dir}1_Mitochondrial_genome/

cd ~/Software/mummer-4.0.0rc1/
mkdir ${mito_gen_dir}
mkdir ${mito_blast}

# Get list of good assemblies -> blast mitochondrial reference -> concatenate all results

#cut -f 1 /data2/alice/WW_project/0_Data/2_Denovo_assemblies/Good_assemblies_stats.tab | sed '1d' > /home/alice/WW_PopGen/Keep_lists_samples/Good_assemblies.args

#sbatch -p normal.168h --array=1-1195%50 Detect_gene_blast_array.sh /home/alice/WW_PopGen/Directories_new.sh /data2/alice/WW_project/0_Data/Zymoseptoria_tritici.MG2.dna.toplevel.mt+_only.fa /home/alice/WW_PopGen/Keep_lists_samples/Good_assemblies.args Illumina ${mito_blast}

# cat ${mito_blast}*blast.tab >  ${mito_blast}Mitochondria.blast_results.tsv
```

```{r find complete mito}

mito_blast_results_complete = read_delim(paste0(mito_blast, "Mitochondria.blast_results.tsv"), delim = " ",
                                col_names = c("sample_id", "gene", "qseqid", "sseqid", "pident", "length",
                                              "mismatch", "gapopen", "qstart", "qend",
                                              "sstart", "send", "evalue", "bitscore"))

mito_blast_results_per_contig = mito_blast_results_complete %>%
  group_by(sample_id, sseqid) %>%
  summarize(Min_coord = min(min(sstart), min(send)), 
            Max_coord = max(max(sstart), max(send)), 
            Length = Max_coord - Min_coord) %>% 
  ungroup()

complete_mito = mito_blast_results_per_contig %>%
  group_by(sample_id) %>%
  summarize(Total_length = sum(Length)) %>% ungroup() %>%
  full_join(mito_blast_results_per_contig, .)%>%
  mutate(Percent = 100*Length/Total_length) %>%
  filter(Percent > 90)  %>%
  filter(Length > 30000)


#Writing the table out to export to the cluster
complete_mito %>%
  dplyr::select(sample_id, sseqid) %>%
  write_tsv(., paste0(mito_blast, "Complete_mitochondria_from_blast.txt"), col_names = F)

```

```{r}
##TO CHECK WHETHER USING ONLY THE LENGTH THRESHOLD WOULD RECOVER HETEROPLASMY!!!

#This section here is to check whether there are samples with two assembled mitochondria
complete_mito2 = mito_blast_results_per_contig %>%
  group_by(sample_id) %>%
  summarize(Total_length = sum(Length)) %>% ungroup() %>%
  full_join(mito_blast_results_per_contig, .)%>%
  mutate(Percent = 100*Length/Total_length) %>%
  filter(Length > 25000)

ggplot(complete_mito2, aes(x = Percent, y = Length)) + 
  geom_point()

```


In the end, I would like to recover the structural variants based on the reference genomes. However, because the mitochondria is linear, spurious rearrangements could be detected when the breakpoint is created by the assembler to linearize the mitochondria. To prevent this from happening, I want to harmonize the breakpoints. The steps for this are:

1. Extract the mitochondrial genome from the *de novo* assemblies
2. Duplicate the mitochondrial genome so it "loops" and has each pieces several times
3. Align the duplicated sequence on the reference sequence and identify breakpoints
4. Identify new start and stop based on the reference sequence and reextract the mitochondrial genome based on these

```{bash aln 3rd mito}
project_dir=/data2/alice/WW_project/
  DATA_DIR=${project_dir}0_Data/
    mito_gen_dir=${DATA_DIR}4_Mitochondrial_genome/
      mito_blast=${mito_gen_dir}0_Mito_blast/
      mito_fasta=${mito_gen_dir}1_Mitochondrial_fastas/
  
  pop_str_dir=${project_dir}2_Population_structure/
    mito_PS_dir=${pop_str_dir}1_Mitochondrial_genome/

cd ~/Software/mummer-4.0.0rc1/
#mkdir ${mito_fasta}
#mkdir ${mito_fasta}0_De_novo
#mkdir ${mito_fasta}1_Tripled
#mkdir ${mito_fasta}2_Aligned
#mkdir ${mito_fasta}3_Harmonized

out_file=${mito_fasta}2_Aligned/All_circular.mcoords
echo -e "Sample Ref_start Ref_stop Denovo_start Denovo_stop" > $out_file

while read sample contig ; 
do echo $contig > temp ; 
# Initial extraction
   python ~/Common_scripts/Filter_fasta.py --list temp --action keep \
      --out ${mito_fasta}/0_De_novo/${sample}.mitochondria.fasta \
      ${DATA_DIR}2_Denovo_assemblies/${sample}.fasta ; 
   sed -i "s/>/>${sample}_/" ${mito_fasta}/0_De_novo/${sample}.mitochondria.fasta ; 

length=$(awk 'FNR==2 { print length }' ${mito_fasta}/0_De_novo/${sample}.mitochondria.fasta) ;

if [ $length -lt 60000 ] ; 
then 
  # Multiple and alignment
     python ~/Common_scripts/Multiply_mito.py \
        --out ${mito_fasta}/1_Tripled/${sample}.mitochondria.triple.fasta \
        ${mito_fasta}/0_De_novo/${sample}.mitochondria.fasta;

     ./dnadiff \
         -p ${mito_fasta}/2_Aligned/IPO323_vs_${sample}  \
         ${DATA_DIR}Zymoseptoria_tritici.MG2.dna.toplevel.mt+_only.fa \
         ${mito_fasta}/1_Tripled/${sample}.mitochondria.triple.fasta

     awk -v sample=${sample} '{print sample, $1, $2, $3, $4}' \
       ${mito_fasta}/2_Aligned/IPO323_vs_${sample}.mcoords \
       >> ${out_file}
fi 

done < ${mito_blast}Complete_mitochondria_from_blast.txt

```

```{r}
mito_aln = read_delim(paste0(mito_fasta, "2_Aligned/All_circular.mcoords"), col_names  = T, delim = " ") %>%
  rowwise() %>%
  mutate(Min_coord_denovo = min(Denovo_start, Denovo_stop), 
         Max_coord_denovo = max(Denovo_start, Denovo_stop)) %>%
  dplyr::select(-Denovo_start, -Denovo_stop)

temp = mito_aln %>%
  group_by(Sample, Ref_start)  %>%
  #mutate(Min_start = min(Min_coord_denovo))  %>%
  mutate(rank  = rank(Min_coord_denovo, ties.method = "random"))  %>%
  filter(Ref_start == 1) %>%
  filter(rank < 3) %>%
  ungroup() %>%
  select(-Max_coord_denovo, -Ref_start, -Ref_stop) %>%
  pivot_wider(names_from = "rank", values_from = Min_coord_denovo)%>%
  select(Sample, Start = `1`, Stop = `2`)  %>% 
  mutate(Fragment = "First")

temp2 = mito_aln %>%
  group_by(Sample, Ref_start)  %>%
  #mutate(Min_start = min(Min_coord_denovo))  %>%
  mutate(rank  = rank(Min_coord_denovo, ties.method = "random"))  %>%
  filter(Ref_start == 1) %>%
  filter(rank > 1 & rank < 4) %>%
  ungroup() %>%
  select(-Max_coord_denovo, -Ref_start, -Ref_stop) %>%
  pivot_wider(names_from = "rank", values_from = Min_coord_denovo) %>%
  select(Sample, Start = `2`, Stop = `3`)%>% 
  mutate(Fragment = "Second")


fragments = bind_rows(temp, temp2) %>%
  left_join(., complete_mito, by =c ("Sample" = "sample_id")) %>%
  mutate(Length2 = (Stop - Start), Diff = (Length + 1) - Length2) %>%
  group_by(Sample)  %>%
  mutate(rank  = rank(Diff, ties.method = "random"))  

fragments %>% 
  filter(rank == 1) %>%
  mutate(Start = Start - 1) %>%
  select(Sample, sseqid, Start, Stop) %>%
  unite(col = "contig", c(Sample, sseqid), remove = F) %>%
  dplyr::select(-sseqid) %>%
  relocate(Sample, contig) %>%
  write_tsv(., paste0(mito_fasta, "3_Harmonized/", "Reextracting_mitochondria.bed"), col_names = F)

```


```{bash aln harmonized mito}
project_dir=/data2/alice/WW_project/
  DATA_DIR=${project_dir}0_Data/
    mito_gen_dir=${DATA_DIR}4_Mitochondrial_genome/
      mito_blast=${mito_gen_dir}0_Mito_blast/
      mito_fasta=${mito_gen_dir}1_Mitochondrial_fastas/
   var_cal_dir=${project_dir}1_Variant_calling/
     mito_SV=${var_cal_dir}6_Mito_SV/
  
  pop_str_dir=${project_dir}2_Population_structure/
    mito_PS_dir=${pop_str_dir}1_Mitochondrial_genome/

cd ~/Software/mummer-4.0.0rc1/
while read sample contig start stop ; 
do 
  echo -e "${contig}\t${start}\t${stop}" > temp.bed ; 
  /home/alice/Software/bedtools getfasta \
    -fi ${mito_fasta}1_Tripled/${sample}.mitochondria.triple.fasta \
    -fo ${mito_fasta}3_Harmonized/${sample}.mitochondria.harmonized.fasta \
    -bed temp.bed
    
  ./dnadiff \
         -p ${mito_SV}IPO323_vs_${sample}  \
         ${DATA_DIR}Zymoseptoria_tritici.MG2.dna.toplevel.mt+_only.fa \
         ${mito_fasta}3_Harmonized/${sample}.mitochondria.harmonized.fasta
         
done < ${mito_fasta}3_Harmonized/Reextracting_mitochondria.bed
```

```{r mito SV}
sample_list = fragments %>% select(Sample) %>% distinct() %>% pull()
file_list = paste0(mito_SV, "IPO323_vs_", sample_list, ".mcoords")
  
  #list.files(path = paste0(mito_SV, "IPO323_vs_"), pattern = "*mcoords", full.names = TRUE)

coords_list = list()
for (i in c(1:length(file_list))) {
  coords_list[[i]] = read_tsv(file_list[[i]], 
         col_names = c("Ref_start", "Ref_end", "Query_start", "Query_end", 
                       "Ref_aln_length", "Query_aln_length", "Percent_ID",  
                       "Ref_length", "Query_length", "Ref_cov", "Query_cov", 
                       "CHROM", "scaf")) 
}

coords_from_aln = do.call(rbind, coords_list) %>%
  mutate(TEMP = gsub("_scaf", ":scaf", scaf)) %>%
  separate(TEMP, into = c("sample_id", "scaffold"), sep = ":")

coords_from_aln %>% group_by(sample_id) %>% count() %>%
  qplot(data =., x = n, geom = "histogram")

coords_from_aln %>% write_tsv(file = paste0(mito_SV, "All_complete_mitochondria.mcoords"))
```

```{r mito snps}
file_list = paste0(mito_SV, "IPO323_vs_", sample_list, ".snps")

snps_list = list()
for (i in c(1:length(file_list))) {
  snps_list[[i]] = read_tsv(file_list[[i]], 
         col_names = c("POS", "REF", "ALT", "Ref", "POS_query",
                       "V1", "V2", "V3", "V4", "V5", "CHROM", "scaf")) 
}

snps_from_aln = do.call(rbind, snps_list) %>%
  mutate(TEMP = gsub("_scaf", ":scaf", scaf)) %>%
  separate(TEMP, into = c("sample_id", "scaffold"), sep = ":") %>%
  dplyr::select(CHROM, POS, REF, ALT, sample_id) 

snps_from_aln %>% write_tsv(file = paste0(mito_SV, "All_complete_mitochondria.snps"))
```



<br><br>