---
title: "World-wide popgen Zt"
author: "Alice Feurtey"
date: "5/5/2020"
output:
  html_document:
    toc: yes
    toc_float: yes
    css: /Users/feurtey/Documents/epur_css.css
    number_sections: no
    code_folding: hide
  #html_document:
   # toc: yes
   # df_print: paged
logo: /Users/feurtey/Documents/Postdoc_Bruce/Communication/Logo_WWZt.png
---


<br><br>

> Here, I analyse and document my progress with the analysis of a world-wide whole genome sampling of *Zymoseptoria tritici*. Some of the analysis are just exploratory while some other are lined up in a clear path to answering questions related to the history of *Z.tritici* and to better understand its adaptation to various climates.

```{r setup, warning=FALSE, message = FALSE}

library(knitr)
library(reticulate)

#Spatial analyses packages
library(raster)
library(sp)
library(rgdal)
library(maps)

#Data wrangling and data viz
library(tidyverse)
library(purrr)
library(RColorBrewer)
library(plotly)
library(cowplot)
library(GGally)
library(corrplot)
library(pheatmap)
library(ggstance)
library('pophelper')
library(ggbiplot)
library(igraph)
library(ggraph)
library(ggtext)

#Pop structure and pop genomic
library(GenomicFeatures)
library(SNPRelate) #PCA
library(LEA) #Clustering
library(pophelper)
library(PopGenome) #Summary statistics
library(gridExtra)

library(ggtree)
library(tidytree)


#GEA
library(lfmm)

#Statistics
library(car)
library(corrr)
library(lsmeans)
library(multcomp)


#Variables
world <- map_data("world")
project_dir="/Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/"

#Data directories
data_dir=paste0(project_dir, "0_Data/")
metadata_dir=paste0(project_dir, "Metadata/")

#Analysis directories
#-___________________
VAR_dir = paste0(project_dir, "1_Variant_calling/")
  depth_per_window_dir = paste0(VAR_dir, "1_Depth_per_window/")
  vcf_dir = paste0(VAR_dir, "4_Joint_calling/")
  mito_SV = paste0(VAR_dir, "6_Mito_SV/")
PopStr_dir = paste0(project_dir, "2_Population_structure/")
mito_PS_dir = paste0(PopStr_dir, "1_Mitochondrial_genome/")
Sumstats_dir = paste0(project_dir, "3_Sumstats_demography/")
TE_RIP_dir=paste0(project_dir, "4_TE_RIP/")
   RIP_DIR=paste0(TE_RIP_dir, "0_RIP_estimation/")
   DIM2_DIR=paste0(TE_RIP_dir, "1_Blast_from_denovo_assemblies/")
GEA_dir=paste0(project_dir, "5_GEA/")
fung_dir=paste0(project_dir, "6_Fungicide_resistance/")
virulence_dir = paste0(project_dir, "7_Virulence/")
sel_dir = paste0(project_dir, "8_Selection/")
  gene_list_dir = paste0(sel_dir, "0_Lists_unique_copy/")

#Files
vcf_name="Ztritici_global_March2021.genotyped.ALL.filtered.clean.AB_filtered.variants.good_samples.SNP.max-m-0.8.maf-0.05.thin-1000bp"
vcf_name_nomaf="Ztritici_global_March2021.filtered-clean.AB_filtered.SNP.max-m-0.8.thin-1000bp"
vcf_name_mito = "Ztritici_global_March2021.genotyped.ALL.filtered.clean.AB_filtered.variants.good_samples.mt."
Zt_list = paste0(metadata_dir, "Ztritici_global_March2021.genotyped.good_samples.args")
gff_file = paste0(data_dir, "Zymoseptoria_tritici.MG2.Grandaubert2015.no_CDS.gff3")
ref_fasta_file = paste0(data_dir, "Zymoseptoria_tritici.MG2.dna.toplevel.mt+.fa")
metadata_name = "Main_table_from_SQL_Feb_2020"
gene_annotation = read_tsv(paste0(data_dir, "Badet_GLOBAL_PANGENOME_TABLE.txt"))

Sys.setenv(PROJECTDIR=project_dir)
Sys.setenv(VARDIR=VAR_dir)
Sys.setenv(VCFDIR=vcf_dir)
Sys.setenv(POPSTR=PopStr_dir)
Sys.setenv(MITOPOPSTR=mito_PS_dir)

Sys.setenv(SUMST=Sumstats_dir)
Sys.setenv(GEADIR=GEA_dir)

Sys.setenv(ZTLIST=Zt_list)
Sys.setenv(GFFFILE = gff_file)
Sys.setenv(REFFILE = ref_fasta_file)
Sys.setenv(VCFNAME=vcf_name)
Sys.setenv(VCFNAME_NOMAF=vcf_name_nomaf)
Sys.setenv(VCFNAME_MITO=vcf_name_mito)

#knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(message = F)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(results = T)


# Metadata and sample lists
##Filtered_samples
filtered_samples = bind_rows(
  read_tsv(paste0(metadata_dir, "Sample_removed_based_on_IBS.args"), col_names = "ID_file") %>%
  mutate(Filter = "IBS"),
read_tsv(paste0(metadata_dir, "Sample_with_too_much_NA.args"), col_names = "ID_file") %>%
  mutate(Filter = "High_NA"),
read_tsv(paste0(metadata_dir, "Samples_to_filter_out.args"), col_names = "ID_file") %>%
  mutate(Filter = "Mutants_etc"))

##Samples in vcf
genotyped_samples = read_tsv(paste0(project_dir, "WW_PopGen/Keep_lists_samples/Ztritici_global_March2021.genotyped.sample_list.args"), 
         col_names = "ID_file")

## Metadata of genotyped samples 
temp = read_tsv(paste0(metadata_dir, metadata_name, "_Description.tab"), col_names = F) %>% pull()

Zt_meta=read_tsv(paste0(metadata_dir, metadata_name, "_with_collection.tab"), 
                 col_names = temp,
                 na = "\\N") %>%
  unite(Coordinates, Latitude, Longitude, sep = ";", remove = F) %>%
  full_join(., genotyped_samples) 

genotyped_samples %>%
  filter(!(ID_file %in% filtered_samples$ID_file)) %>%
    write_tsv(Zt_list, col_names = F)



#Define colors
## For continents
myColors <- c("#04078B", "#a10208", "#FFBA08", "#CC0044", "#5C9D06", "#129EBA","#305D1B")
names(myColors) = levels(factor(Zt_meta$Continent))
Color_Continent = ggplot2::scale_colour_manual(name = "Continent", values = myColors)
Fill_Continent = ggplot2::scale_fill_manual(name = "Continent", values = myColors)

## For correlations
mycolorsCorrel<- colorRampPalette(c("#0f8b8d", "white", "#a8201a"))(20)

#Random gradients
greens=c("#1B512D", "#669046", "#8CB053", "#B1CF5F", "#514F59")
blues=c("#08386E", "#1C89C9", "#28A7C0", "#B0DFE8", "grey")
```

Out of date:
```{bash Outdate mportation from cluster, eval = F}
# 1 - Variant calling
rsync -avP \
  alice@130.125.25.187:/data2/alice/WW_project/1_Variant_calling/1* \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/1_Variant_calling/

rsync -avP \
  alice@130.125.25.187:/data2/alice/WW_project/1_Variant_calling/2* \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/


# 4 - TE and RIP
rsync -avP \
  alice@130.125.25.187:/data2/alice/WW_project/4_TE_RIP/0_RIP_estimation/*txt \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/4_TE_RIP/0_RIP_estimation/
#Composite_index.txt
#GC_percent.txt
#Nb_reads.txt
#Nb_reads_per_TE.txt

rsync -avP \
  alice@130.125.25.187:/data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/1_Blast_dim2_deRIPped/*txt \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/

```

```{bash Importation from cluster, eval = F}
# Uploading commands from the cluster to my computer.

# 1 - Variant calling - Depth 
rsync -avP alice@130.125.25.244:/data2/alice/WW_project/0_Data/Zymoseptoria_tritici.MG2.dna.toplevel.mt+.1kb_windows.nuc_GC.tab ../0_Data/
rsync -avP alice@130.125.25.244:/data2/alice/WW_project/1_Variant_calling/1_Depth_per_window/Depth_per*summary.q30.txt  \
   /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/1_Variant_calling/1_Depth_per_window/
# Depth_per_sample_core_chr_summary.q30.txt
# Depth_per_sample_summary.q30.txt
# Depth_per_chromosome_summary.q30.txt
rsync -avP alice@130.125.25.244:/data2/alice/WW_project/1_Variant_calling/2_Depth_per_gene/Depth_per_genes_normalized.txt \
    ../1_Variant_calling/2_Depth_per_gene/
rsync -avP alice@130.125.25.244:/home/alice/WW_PopGen/Keep_lists_samples/Ztritici_global_March2021.genotyped.good_samples.args \
  ../WW_PopGen/Keep_lists_samples/
  
# 1 - Variant calling - SV
rsync -avP alice@130.125.25.244:/data2/alice/WW_project/1_Variant_calling/6_Mito_SV/All_complete_mitochondria.* \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/1_Variant_calling/6_Mito_SV/
#All_complete_mitochondria.mcoords
#All_complete_mitochondria.snps

# 2 -Population structure
rsync -avP alice@130.125.25.244:/data2/alice/WW_project/2_Population_structure/1_Mitochondrial_genome/Mitochondria.blast_results.tsv\
    ../2_Population_structure/1_Mitochondrial_genome/


# 4 - TE and RIP
rsync -avP \
  alice@130.125.25.244:/data2/alice/WW_project/4_TE_RIP/0_RIP_estimation/Nb_reads* \
  /Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/4_TE_RIP/0_RIP_estimation/
# Nb_reads_per_TE.txt
# Nb_reads.txt


```


# Sampling
***


The sampling of _Z.tritici_ isolated from the natural environment covers almost the entirety of the wheat-grown continents. It is, however, highly heterogeous. Europe has the highest sampling density. Several locations are heavily sampled, such a fields in Switzerland or the US.
Some of the available genomes are still under embargo (waiting for the publication of their creator). We are also thinking about sequencing more genomes. Here you can view these different datasets on a map. Please select and unselect the different values to have a view of the changes with added datasets.

* "Usable genomes" are the genomes we have already and which have no embargo on publication.
* "Present and future" are the isolates sequenced already and without embargo plus the planned sequencing
* "Present, future and JGI" are the isolates described above plus the JGI genomes

```{r Sampling map , message = F, warning=F, eval= T}

#kable(Zt_meta %>% dplyr::count(Collection, name = "Number of genomes"))
Zt_meta %>% dplyr::count(Collection, name = "Number of genomes")
max_circle = max(Zt_meta %>%
  dplyr::count(Latitude, Longitude, name = "Number_genomes") %>%
  dplyr::select(Number_genomes))

temp = Zt_meta %>%
   dplyr::count(Country, Latitude, Longitude, name = "Number_genomes") %>%
   filter(Number_genomes > 0)

isolate_map = ggplot() + theme_void() +
  geom_polygon(data = world, aes(x=long, y = lat, group = group), fill="#ede7e3", alpha=0.7) +
  geom_point (data = temp, aes(x=as.numeric(Longitude), y=as.numeric(Latitude),
                                    size=Number_genomes,
                                    text = Country),
                                  alpha = 0.6, color = "#16697a") +
  scale_size("Number of genomes", limits = c(1, max_circle))
isolate_map

```




The sampling also covers a wide range of years: starting from 1990 to 2017. Just as with the geographical repartition, some years are heavily sampled, reflecting sampling in specific fields done for previous experiments.
```{r plot sampling time, message = F, warning=F}
temp = as_tibble(c(min(Zt_meta$Sampling_Date, na.rm = T) : max(Zt_meta$Sampling_Date, na.rm = T))) %>%
  mutate(`Sampling year` = as.character(value))

sum_temp = Zt_meta %>%
    mutate(`Sampling year` = as.character(Sampling_Date)) %>%
    dplyr::count(`Sampling year`, Continent) %>%
    full_join(., temp) %>%
    mutate(`Genome number` = replace_na(n, 0))

sum_temp %>%
ggplot(aes(x=`Sampling year`, y =`Genome number`, fill = Continent)) +
  geom_bar(stat = "identity") +
  theme_bw() + theme(axis.title = element_blank(),
                     axis.text.x = element_text(angle = 60, hjust = 1)) +
  Fill_Continent
```



<br><br>


# Variant calling
***
## Whole chromosomes SNV
__Question__: How prelavent is aneuploidy in natural populations of _Z.tritici_? In the case of accessory chromosomes, is there a correlation between phylogeny, environment, host or time and the presence/absence of some chromosomes?

__Methods__: Based on the depth of coverage for all samples, we can identify for both core and accessory chromosomes whether each isolates includes 1, 0 or several copies. 

```{r chr depth}
core_depth = read_tsv(paste0(depth_per_window_dir, "Depth_per_sample_core_chr_summary.q30.txt")) %>%
  mutate(Median_core = Median)

chrom_depth = read_tsv(paste0(depth_per_window_dir, "Depth_per_chromosome_summary.q30.txt")) %>%
  left_join(., core_depth %>% 
  dplyr::select(Sample, Median_core)) %>%
  mutate(Relative_depth = Median/Median_core) %>%
  left_join(.,Zt_meta, by = c("Sample" = "ID_file")) %>%
  filter(CHROM != "mt") %>%
  mutate(Sample = fct_reorder(Sample, Sampling_Date)) %>%
  mutate(Sample = fct_reorder(Sample, Country)) %>%
  mutate(Sample = fct_reorder(Sample, Continent)) 

heatmap_depth = chrom_depth %>%
  filter(CHROM != "mt") %>%
  ggplot(aes(x = as.numeric(CHROM), y=Sample, fill=Relative_depth)) +
  geom_tile() + scale_fill_gradient2(low="white", high = "#479DAE") +
  geom_vline(xintercept = 13.5, linetype = "longdash", colour = "gray20") +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank(), axis.ticks.y=element_blank()) +
  labs(fill = "Depth", x= "Chromosome") + xlim(c(0.5, 21.5))


plot_continent = chrom_depth %>%
  ggplot(aes(x = 1, y=Sample, fill=Continent)) +
  geom_tile(aes(width = 2))  +
  theme_classic() +
  theme(axis.text.y = element_blank(), axis.ticks.y=element_blank(),
        legend.position="left",
        axis.text.x=element_text(colour="white")) +
  labs(y= "Isolate") + Fill_Continent

plot_grid(plot_continent, heatmap_depth, rel_widths = c(2, 5))

```
In the heatmap, I represent the depth normalized by the median depth over all core chromosomes. As expected, the copy-number variation at the chromosome scale affects mostly the accessory chromosomes (AC). There is some presence of supernumerary AC and a lot of presence-absence variation. Supernumerary chromosomes can also be found in the core chromosomes but this is almost anecdotal as over the whole sampling this was found only in 9 cases.

```{r low/high CHR}
Lthres = 0.50
Hthres = 1.50
depth = chrom_depth %>%
  dplyr::mutate(Depth_is = ifelse(Relative_depth > Hthres, "High",ifelse(Relative_depth < Lthres, "Low", "Normal"))) %>%
  mutate(CHROM = fct_reorder(CHROM, as.numeric(CHROM)))  

bar_Ndepth_per_CHR =ggplot(depth, aes(x = CHROM, fill = Depth_is)) +
  geom_bar(stat = "count") +
  scale_fill_manual(values =c("#16697a", "#82c0cc", "#EDE7E3")) +
    theme_light()+
    labs(x= "Chromosome", y = "Number of isolates")

#lollipop plots
##For high normalized depth values
temp = depth %>%
  filter(Depth_is == "High") %>%
  dplyr::group_by(CHROM) %>%
  dplyr::count() %>%
  mutate(CHROM = fct_reorder(CHROM, as.numeric(CHROM))) 
lolhigh =  ggplot(temp, aes(x = as.character(CHROM), y = n)) +
    geom_segment( aes(x=as.character(CHROM), xend=as.character(CHROM), y=0, yend=max(temp$n)),
                  color="grey80", size = 1) +
    geom_segment( aes(x=as.character(CHROM), xend=as.character(CHROM), y=0, yend=n),
                  color="grey20", size = 1) +
    geom_point( color="#16697a", size=4)  +
    geom_text(aes( label = n,
                     y= n), stat= "identity",
              hjust = -0.5, vjust = -0.2) +
    theme_light() +
    theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10)
    ) +
    ylim(c(0,max(temp$n)+2+ max(temp$n)*0.1)) +
    labs(x= "Chromosome", y = "Number of isolates with supernumerary chromosome") +
    coord_flip()

##For low normalized depth values
temp = depth %>%
  filter(Depth_is == "Low") %>%
  dplyr::group_by(CHROM) %>%
  dplyr::count()%>%
  mutate(CHROM = fct_reorder(CHROM, as.numeric(CHROM)))

lollow = ggplot(temp, aes(x = CHROM, y = n)) +
    geom_segment( aes(x=CHROM, xend=CHROM, y=0, yend=max(temp$n)),
                  color="grey80", size = 1) +
    geom_segment( aes(x=CHROM, xend=CHROM, y=0, yend=n),
                  color="grey20", size = 1) +
    geom_point( color="#82c0cc", size=4)  +
    geom_text(aes( label = n,
                     y= n), stat= "identity",
              hjust = -0.5, vjust = -0.2) +
    theme_light() +
    theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10)
    ) +
    ylim(c(0,max(temp$n)+ max(temp$n)*0.1)) +
    labs( x= "Chromosome", y = "Number of isolates without chromosome") +
    coord_flip()

bottom_row <- cowplot::plot_grid(lolhigh, lollow, labels = c('B', 'C'), label_size = 12)

plot_grid(bar_Ndepth_per_CHR, bottom_row, labels = c('A', ''), label_size = 12, ncol = 1)
```

Here is a table including the isolates with supernumerary _core_ chromosomes.
```{r Supernumerary chromosomes table}
depth  %>%
  dplyr::filter(Depth_is == "High") %>%
  dplyr::filter(as.numeric(CHROM) < 13) %>%
  dplyr::select(Sample, CHROM, Median, Median_core, Collection, Country)
```

And an overlook of the accessory chromosomes PAV per continent (only considering continents with more than 10 isolates).
```{r AC chr PAV per continent}
depth %>%
  dplyr::filter(as.numeric(CHROM) > 13) %>%
  dplyr::group_by(Continent, CHROM) %>%
  dplyr::mutate(Count_sample_per_continent = n()) %>%
  dplyr::filter(Count_sample_per_continent >= 10) %>%
  ggplot(aes(x = Continent, fill = Depth_is)) +
  geom_bar(position = "fill" ) + facet_wrap(CHROM~.) +
  theme_light() +
  scale_fill_manual(values = c("#16697a", "#82c0cc", "#EDE7E3")) +
    theme(axis.text.x = element_text(angle = 40, hjust = 1)) +
  ylab("Proportion of chromosomes") + xlab("")
```


## Genes PAV
__Question__: Could genes PAV be related to phylogeny, environment, host or time? What about predicted effector genes?

__Methods__: Based on depth of coverage + SGSGeneloss
For this section, iI expanded the gene selection from all genes in the pangenome. This means remapping everything unfortunately, but it captures more or the overall diversity and might be the only way to catch some population specific variants.


```{r dispensability score}

#This file is coming from the Depth.rmd script on the cluster.
depth_per_gene = read_tsv(paste0(VAR_dir,"2_Depth_per_gene/Depth_per_genes_normalized.txt")) %>%
  filter(Median_core > 10) 

coords = read_tsv(gff_file, comment = "#", col_names = F) %>%
  filter(X3 == "gene") %>%
  separate(X9, into=c("temp", "Gene_ID", "temp2", "Name"), sep = "[=;]") %>%
  dplyr::select(CHROM = X1, Gene_ID, Start = X4, End = X5)
  
  
ends = coords %>%
  dplyr::group_by(Gene_ID, CHROM) %>%
  summarize(max = max(End))


depth_per_gene %>% 
  filter(Norm_median_depth < 2) %>% 
  dplyr::group_by(CHROM, Sample) %>%
  sample_n(20) %>%
  dplyr::summarize(Average = mean(Norm_median_depth))%>% 
  ggplot(aes(x = reorder(as.character(CHROM), sort(as.numeric(CHROM))), y = Average)) + 
  geom_violin(aes(fill = CHROM < 14), alpha =.6)  + 
  theme_bw() +
  labs(x = "Chromosomes", y = "Average of the normalized depth per gene per sample")

```


Let's attempt to create a PCA based on the normalized depth per gene.
```{r PCA norm_depth}
library(FactoMineR)
depth_genes_PCA = depth_per_gene %>%
  filter(Median_core > 10) %>%
  dplyr::select(Sample, Name, Norm_median_depth) %>%
  mutate(Norm_median_depth = as.numeric(Norm_median_depth)) %>%
  pivot_wider(names_from = Name, values_from = Norm_median_depth, values_fill = 0)

temp = as.data.frame(depth_genes_PCA)[complete.cases(depth_genes_PCA),2:ncol(depth_genes_PCA)]
temp2 = temp[, sample(ncol(temp), size=1000,replace=FALSE)]
temp2 = sapply( temp2, as.numeric )

res.pca = PCA(temp2, scale.unit=TRUE, ncp=10, graph=F)

results = as.tibble(res.pca$ind$coord) %>%
   mutate(ID_file = as.data.frame(depth_genes_PCA)[complete.cases(depth_genes_PCA),1]) %>%
  left_join(.,Zt_meta)

p = ggplot(results, aes(x = Dim.1, y = Dim.2, text = ID_file, color = Continent)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(res.pca$eig[1,2]), "%)"),
       y = paste0("PC 2 (", round(res.pca$eig[2,2]), "%)")) +
  Color_Continent +
  theme_bw()
ggplotly(p)

#p = ggplot(results, aes(x = Dim.1, y = Dim.2, text = ID_file, color = Collection)) +
#  geom_point() +
#  labs(x = paste0("PC 1 (", round(res.pca$eig[1,2]), "%)"),
#       y = paste0("PC 2 (", round(res.pca$eig[2,2]), "%)")) +
#  theme_bw()
#ggplotly(p)


```

Different datasets have very different depth of coverage. It is possible that this explains thee clustering observed above. What if I simplified the matrix to include only rounded numbers which would be an approximation of CNV?
```{r PCA CNV}
library(FactoMineR)
depth_genes_PCA = depth_per_gene %>%
  filter(Median_core >= 10 & Median_core <= 50) %>%
  dplyr::select(Sample, Name, Norm_median_depth)  %>%
  mutate(Norm_median_depth = round(Norm_median_depth)) %>%
  pivot_wider(names_from = Name, values_from = Norm_median_depth, values_fill =0 )


temp = as.data.frame(depth_genes_PCA)[complete.cases(depth_genes_PCA),2:ncol(depth_genes_PCA)]
temp2 = temp[, sample(ncol(temp), size=1000,replace=FALSE)]
temp2 = sapply( temp2, as.numeric )

res.pca = PCA(temp2, scale.unit=TRUE, ncp=10, graph=F)

results = as.tibble(res.pca$ind$coord) %>%
   mutate(ID_file = as.data.frame(depth_genes_PCA)[complete.cases(depth_genes_PCA),1]) %>%
  left_join(.,Zt_meta)

p = ggplot(results, aes(x = Dim.1, y = Dim.2, text = ID_file, color = Continent)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(res.pca$eig[1,2]), "%)"),
       y = paste0("PC 2 (", round(res.pca$eig[2,2]), "%)")) +
  Color_Continent +
  theme_bw()
ggplotly(p)
p = ggplot(results, aes(x = Dim.2, y = Dim.3, text = ID_file, color = Continent)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 2 (", round(res.pca$eig[1,2]), "%)"),
       y = paste0("PC 3 (", round(res.pca$eig[2,2]), "%)")) +
  Color_Continent +
  theme_bw()
ggplotly(p)

#p = ggplot(results, aes(x = Dim.1, y = Dim.2, text = ID_file, color = Collection)) +
#  geom_point() +
#  labs(x = paste0("PC 1 (", round(res.pca$eig[1,2]), "%)"),
#       y = paste0("PC 2 (", round(res.pca$eig[2,2]), "%)")) +
#  theme_bw()
#ggplotly(p)


```
Hum... Something looks really wrong! Not sure why. Let's look at it again at some point.




### GC bias
Estimates for the GC bias were done per isolate in the Depth.Rmd script. Here, I simply load this data and represent it graphically.
```{r GC per win}

# 

GC_per_window = read_tsv(paste0(data_dir, "Zymoseptoria_tritici.MG2.dna.toplevel.mt+.1kb_windows.nuc_GC.tab")) %>%
  mutate(GC = round(`5_pct_gc`, 2)) %>%
  filter( !is.na(`#1_usercol`))

temp = GC_per_window %>%
  filter(`#1_usercol` < 14)  %>%
  dplyr::select(CHROM = `#1_usercol`, Win_start = `2_usercol`, Win_stop = `3_usercol`, GC) %>%
  group_by(GC) %>%
  dplyr::count() 

# Histogram of GC values
xint = median(GC_per_window$GC)
temp %>%
  ggplot(aes(x = GC, y = n, fill = n > 40)) +
    geom_bar(stat = "identity") +
    theme_light() +
  scale_fill_manual(values =c( "#82c0cc", "#EDE7E3"))+
  geom_vline(xintercept = xint, col = "#82c0cc") +
  annotate("text", label = paste0("Median GC is ", xint), 
           x = xint - xint*0.2, y = 5200, 
           size = 4, colour = "#82c0cc", fontface = "bold")

```
The distribution of GC is slightly skewed in the GC-rich side, with a median above 0.5. However, there is an AT-rich fat tail, or even a bimodal distribution. These windows are most probably containing RIP-affected repeated regions.

From there, we need to know if the different collections present GC bias in their sequencing. We expect a batch effect in the sequencing here since we have data coming from a lot of different years and labs (and because batch effect happens in general).
```{r GC bias per collection}
GC_bias = read_tsv(paste0(depth_per_window_dir, "GC_bias_per_sample.txt"))

temp = GC_bias %>%
  filter(Collection != "\\N") %>%
  group_by(Collection) %>%
  dplyr::count() %>%
  filter(n >= 20) 

inner_join(temp, GC_bias) %>%
  group_by(Collection) %>%
  mutate(Median = median(GC_bias_slope)) %>%
 ggplot(., aes(x = reorder(Collection, Median), y = GC_bias_slope, fill = reorder(Collection, Median))) +
  geom_violin(alpha = .7) +
  theme_bw()  +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1),
        plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  labs(x = "Collection", fill = "Collection", y = "GC bias estimate")
```

It is very clear that we do have a batch effect but also that some datasets are very, very biased. The older Hartmann data (also called Qst population) in particular is strongly biased.

<br><br>




# Population structure / biogeography
***
__Question__: Is the world-wide population of _Z.tritici_ structured? If so, is it structured according to geography, host or time (or any other relevant info we hopefully have)?

Previous genomic work has shown very clear structure between populations of _Z.tritici_. However,the sampling was extremely heterogeneous. With a more geographically even sampling, do we also observe a clear-cut structure?
<br>
__Methods__: Analyses to create would be:

 * PCA
 * Structure-like analysis,
 * Tree (rooted on Za to infer origin if pattern?) #TODO
 * Map with cluster if clusters #TODO


## Principal Component Analysis

### PCA with all continents
As a first method to investigate the population structure of _Z.tritici_ at the world-wide scale, I chose to do a principal component analysis based on a subset of the SNPs. This PCA confirms previous results of a geographically structured species. Oceania emerges quite distincly as three separate clusters: one in New-Zealand and two Australian (see below for a more in-depth analysis of this pattern). North-America is also quite serapate. The distinction between the rest of the geographical location is not clear in this PCA, although PC3 might show a slight differenciation between Europe and the Middle-East.

```{bash, eval = F}

vcftools --vcf ${VCFDIR}${VCFNAME}.recode.vcf \
  --keep $ZTLIST \
  --non-ref-ac-any 1 \
  --remove-filtered-all --recode --recode-INFO-all \
  --out ${VCFDIR}${VCFNAME}.pass

```


```{r PCA All run and plot, results = F}
snpgdsVCF2GDS(paste0(vcf_dir, vcf_name, ".recode.vcf"),
              paste0(PopStr_dir, vcf_name, ".recode.gds"), method="biallelic.only")
genofile <- snpgdsOpen(paste0(PopStr_dir, vcf_name, ".recode.gds"))
pca <-snpgdsPCA(genofile)
snpgdsClose(genofile)

pca2 = as_tibble(pca$eigenvect) %>% dplyr::select(V1:V4)
colnames(pca2) = c("PC1", "PC2", "PC3", "PC4")
pca2 = pca2 %>%
  dplyr::mutate(sample_id = pca$sample.id ) %>%
  dplyr::right_join(., Zt_meta, by = c("sample_id" = "ID_file")) %>%
  unite(sample_id, Country, col = "for_display", remove = F) %>%
  filter(!is.na(PC1))

as.tibble(pca$eigenval[!is.na(pca$eigenval)]) %>%
  ggplot(aes(x = c(1:length(pca$eigenval[!is.na(pca$eigenval)])),
             y =value)) + geom_point() +
  theme_bw()


eigen_sum = sum(pca$eigenval[!is.na(pca$eigenval)])
p = ggplot(pca2, aes(x = PC1, y= PC2, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(pca$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 2 (", round(pca$eigenval[2]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw()

#p
ggplotly(p)

q = ggplot(pca2, aes(x = PC3, y= PC4, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 3 (", round(pca$eigenval[3]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 4 (", round(pca$eigenval[4]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw()

#q
ggplotly(q)
```





``` {r PCA ggpairs}

p = ggpairs(pca2, columns = c(1:4),
            ggplot2::aes(col=Continent, fill = Continent, alpha = 0.6),
            title = "PCA based thinned SNPs",
            upper = list(continuous = "points", combo = "box_no_facet"))

for(i in 1:p$nrow) {
  for(j in 1:p$ncol){
    p[i,j] <- p[i,j] + theme_bw() + Color_Continent + Fill_Continent
  }
}

p
```


## Structure-like clustering

The clustering here is done by using the snmf method from the LEA R package (http://membres-timc.imag.fr/Olivier.Francois/LEA/) on the same subset of SNPs as the PCA, but without any missing data. I ran the analysis for a K (number of cluster inferred) ranging from 1 to 15 and with 10 repeats for each K.

```{bash format snmf, eval = F}

vcftools --vcf ${VCFDIR}$VCFNAME.recode.vcf \
  --keep $ZTLIST \
  --remove-filtered-all --extract-FORMAT-info GT \
  --max-missing 1.0 --min-alleles 2 --max-alleles 2 \
  --maf 0.05 \
  --out ${POPSTR}$VCFNAME.pass_noNA


cat  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT | cut -f 3- \
    > ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2
cat  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT | cut -f 1,2 \
    > ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT.pos
head -n1 ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2 | gsed "s/\t/\n/g"  \
    > ${POPSTR}$VCFNAME.pass_noNA.ind
gsed "s/\t//g"  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2 | tail -n +2 \
    > ${POPSTR}$VCFNAME.pass_noNA.geno

```

```{r run snmf, eval =F}
project = snmf(paste0(PopStr_dir, vcf_name, ".pass_noNA.geno"), K=1:15, entropy = TRUE,
                        repetitions = 10, project = "new", ploidy = 1)
```
First, let's look at the cross-validation results. sNMF estimates an entropy criterion which evaluates the quality of fit of the model to the data, potentially helping to find the best number of ancestral populations.
```{r Cross-entropy plot}
#Sample names
indv_snmf = read_tsv(paste0(PopStr_dir, vcf_name, ".pass_noNA.ind"), col_names = F)
names(indv_snmf) = "Sample"

#Load project
project = load.snmfProject(paste0(PopStr_dir, vcf_name, ".pass_noNA.snmfProject"))
plot(project, col = "goldenrod", pch = 19, cex = 1.2)

K_colors = c("#f9c74f", "#f9844a", "#90be6d", "#f5cac3", 
"#83c5be", "#f28482", "#577590", "#e5e5e5", "#a09abc",  "#52796f")
K_list = c(1:15)

#Reading data in
datalist = list()
for (i in K_list){
  best = which.min(cross.entropy(project, K = i))
  temp = as.data.frame(Q(project, i, best))
  temp= cbind(indv_snmf, temp)

  temp = temp %>%
    gather("Cluster", "Admix_coef", -"Sample") %>%
    mutate(K=i)
   datalist[[i]] = as.tibble(temp)
}

snmf_results_per_K = bind_rows(datalist) %>%
  inner_join(., Zt_meta, by = c("Sample" = "ID_file"))  %>%
  mutate(Country = ifelse(Country == "USA", Region, Country)) %>%
  unite(Continent, Country, col = "for_display", remove = F)  

```


In the case of our analysis, we do not have a very clear-cut minimum value for the cross-entropy criterion value. There is however a plateau starting from K=9 or K=10. I chose to represent as barplots the best run for each value of K (as defined as the one with the lowest cross-entropy value). This seem to confirm the choice of a reasonable K value at 10 since no new major cluster seem to appear in the at higher values. 

The results from the PCA and from the clutering analysis are coherent: Oceania separates into 3 clusters (one in New_Zealand, and two in Australia) and the North American isolates form two separate clusters. Higher K values also distinguish a Middle-Eastern/African cluster from the European cluster, representing the two extreme points of the gradient found between these populations in the PCA.

```{r sNMF pretty plots}


afiles = character(length(K_list))
for (i in K_list){
  best = which.min(cross.entropy(project, K = i))
  afiles[i] = Sys.glob(paste0(PopStr_dir, vcf_name, ".pass_noNA.snmf/K",i, "/run", best, "/*Q"))
}

# create a qlist
qlist <- readQBasic(afiles)
al_qlist = alignK(qlist)

lab_set = inner_join(indv_snmf, Zt_meta, by = c("Sample" = "ID_file")) %>%
  mutate(Country = ifelse(Country == "USA", Region, Country)) %>%
  dplyr::select(Continent, Country) %>%
  mutate(Continent = ifelse(is.na(Continent), "Unknown", Continent),
         Country = ifelse(is.na(Country), "Unknown", Country))
#Low numbers
from = 2
up_to = 5
p1 <-   plotQ(alignK(qlist[from:up_to], type = "across"),
            imgoutput="join",
            returnplot=T,exportplot=F,
            quiet=T,basesize=11,
            splab= paste0("K=", K_list[from:up_to]),
            grplab=lab_set, ordergrp=T, grplabangle = 40, grplabheight = 2, grplabsize = 2,
            clustercol = K_colors)

grid.arrange(p1$plot[[1]])

#Medium numbers
from = 6
up_to = 10
p2 <-   plotQ(alignK(qlist[from:up_to], type = "across"),
            imgoutput="join",
            returnplot=T,exportplot=F,
            quiet=T,basesize=11,
            splab= paste0("K=", K_list[from:up_to]),
            grplab=lab_set, ordergrp=T, grplabangle = 40, grplabheight = 2, grplabsize = 2,
            clustercol = K_colors)
grid.arrange(p2$plot[[1]])

#High numbers
from = 11
up_to = 15
p2 <-   plotQ(alignK(qlist[from:up_to], type = "across"),
            imgoutput="join",
            returnplot=T,exportplot=F,
            quiet=T,basesize=11,
            splab= paste0("K=", K_list[from:up_to]),
            grplab=lab_set, ordergrp=T, grplabangle = 40, grplabheight = 2, grplabsize = 2,
            clustercol = c("#f9c74f", "#f9844a", "#90be6d", "#f5cac3", 
"#83c5be", "#f28482", "#577590", "#e5e5e5", "#a09abc",  "#52796f",
"#219ebc", "#003049", "grey", "#283618", "white"))
grid.arrange(p2$plot[[1]])
```


__Note__: I am not entirely sure about whether the high density of isolates from specific fields could bias the results. I remember it was the case with STRUCTURE, not sure if it is also the case of sNMF. To be checked.

```{r}

chosen_threshold = 0.7
chosen_threshold2 = 0.75


temp = bind_rows(snmf_results_per_K %>%
    filter(Admix_coef > 0.7) %>% 
    mutate(Threshold = "> 0.7"), 
  snmf_results_per_K %>%
    filter(Admix_coef > 0.75) %>%
    mutate(Threshold = "> 0.75"))


temp %>%
    dplyr::group_by(K, Threshold) %>%
    dplyr::count() %>%
    ggplot(aes(x = K, y = n, fill = Threshold)) +
       geom_bar(stat = "identity", position = "dodge") +
       theme_bw() + scale_fill_manual(values = c(blues[5], blues[3], blues[1]))



temp2 = temp %>%
  dplyr::group_by(Continent, for_display, Cluster, K, Threshold) %>%
  dplyr::count() 


temp2 %>%
  filter(K > 6 & K < 13) %>%
  ggplot(aes(x = Cluster, y = for_display,
             size = n, color = Continent)) +
  geom_point(alpha = 0.3) + Color_Continent+ theme_bw() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  facet_grid(rows = vars(Threshold), cols = vars(K), scales = "free_x") + 
    labs(x = "", title = "Number of genotypes with admix coef > 0.8") 


```



```{r sNMF bubbles}
#These values are chosen based on the plot above
chosen_threshold = 0.75
chosen_K = 10

#Table
temp %>%
  filter(K == chosen_K) %>%
  filter(Admix_coef > 0.8) %>%
  dplyr::group_by(Continent, Cluster) %>%
  dplyr::count() %>%
  pivot_wider(names_from = Continent, values_from =n, values_fill = 0)


#Bubble plot
snmf_results_per_K %>%
  filter(K == chosen_K) %>%
  dplyr::group_by(Continent, for_display, Cluster) %>%
  dplyr::summarize(Ave_admix_coef = round(mean(Admix_coef), 2)) %>%
  dplyr::filter(Ave_admix_coef >= 0.02) %>%
  ggplot(aes(x = for_display, y = Cluster,
             size =  Ave_admix_coef, color = Continent)) +
  geom_point(alpha = 0.5) + Color_Continent+ theme_bw() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
    labs(x = "", title = "Average admixture coefficient per country")

#Looking at individuals with admixture coef higher than the threshold defined above.
high_anc_coef_snmf = snmf_results_per_K %>%
  filter(K == chosen_K) %>%
  filter(Admix_coef > chosen_threshold)

##Table
kable(high_anc_coef_snmf %>%
  dplyr::group_by(for_display, Cluster) %>%
  dplyr::count() %>%
  pivot_wider(names_from = Cluster, values_from = n, values_fill = list(n = 0)))

##Pretty plot
p_cluster = high_anc_coef_snmf %>%
  dplyr::group_by(Continent, for_display, Cluster) %>%
  dplyr::count() %>%
  ggplot(aes(x = for_display, y = Cluster,
             size = n, color = Continent)) +
  geom_point(alpha = 0.5) + Color_Continent+ theme_bw() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
    labs(x = "", title = "Number of genotypes with admix coef > 0.8")
p_cluster

##Writing out tables for later
high_anc_coef_snmf %>% dplyr::select(Sample) %>%
  write_tsv(., path = paste0(PopStr_dir, vcf_name, ".pass_noNA.high_anc_coef_snmf.ind"),
            col_names = F)
high_anc_coef_snmf %>%
  write_tsv(., path = paste0(PopStr_dir, vcf_name, ".pass_noNA.high_anc_coef_snmf.tsv"),
            col_names = T)
```





## Population trees
In the steps before, I have learned about population history indirectly by inferring genetic populations from the genomic data. The relationship between the population and the underlying demography is not explicit in these however. It is possible however to infer splits between populations and create a population tree. Here, I use [treemix](https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1002967), which takes into account the possibility of gene flow between populations and indeed test of it in the process of creating a population tree.

Because the populations in the clustering were not perfectly distinct from one another, I start with "discretized" populations by choosing only the isolates with high ancestry in one of the sNMF clusters.
```{bash discretized pop vcf, eval = F}
vcftools --vcf ${VCFDIR}$VCFNAME.recode.vcf \
  --keep ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.ind \
  --remove-filtered-all --extract-FORMAT-info GT \
  --max-missing 1.0 --min-alleles 2 --max-alleles 2 \
  --maf 0.05 \
  --out ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf

cat  ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.GT.FORMAT | cut -f 3- \
   >  ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.GT.FORMAT2
```


```{python convert genotype file to treemix}
from collections import defaultdict

#For each isolate, store its pop (as in sampling site) in a dictionary
dict_pop = dict(zip(r.high_anc_coef_snmf["Sample"],
    r.high_anc_coef_snmf["Cluster"]))

#Keep a list of the pop names/coordinates to write in the same order later
all_pops = sorted(list(set(r.high_anc_coef_snmf["Cluster"])))
out_name = r.PopStr_dir + r.vcf_name + ".pass_noNA.high_anc_coef_snmf.treemix"


out = open(out_name, "w")
shutup = out.write(" ".join(all_pops) + "\n")

with open(r.PopStr_dir + r.vcf_name + ".pass_noNA.high_anc_coef_snmf.GT.FORMAT2", "r") as input_snps :
  for i, snp in enumerate(input_snps) :
    #Setting two dictionaries with values at 0
    dict_snp0 = defaultdict(int)
    dict_snp1 = defaultdict(int)
    Lets_write = True

    #The first line is the name of the isolates
    if i == 0 :
      indv = snp.strip().split("\t")
      Lets_write = False
    else :
      #Keeping isolate name and allelic value together
      alleles = zip(indv, snp.strip().split("\t"))
      #...and counting the O and 1 based on the pop
      for ind, allele in alleles:
        if allele == "0" :
          dict_snp0[dict_pop[ind]] += 1
        elif allele == "1" :
          dict_snp1[dict_pop[ind]] += 1
        else :
          print("Only biallelic please!!!!")
          Lets_write = False
    #If I have not found anything weird, I will write the result to the output file.
    if Lets_write :
      shutup = out.write(" ".join([",".join([str(dict_snp0[pop]), str(dict_snp1[pop])])  for pop in all_pops]) + "\n")

out.close()
```

```{bash run treemix, eval = F, message = F}
gzip ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.treemix

treemix \
  -i ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.treemix.gz \
  -o ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.treemix.out \
  -m 2 -root V3

```

```{r plot treemix}
source("/Users/feurtey/Documents/Software/treemix-1.13/src/plotting_funcs.R")
t = plot_tree(paste0(PopStr_dir, vcf_name, ".pass_noNA.high_anc_coef_snmf.treemix.out"))
p_cluster
```

Along with the treemix software, are distribution the software treepop and fourpop. These measure f3 and f4 statistics which test for treeness in population trees.

The three-population test is of the form f3(A;B;C), where a significantly negative value of the f3 statistic implies that population A is admixed. The output is four columns: populations | f3 statistic | standard error | Z-score
```{bash run threepop}
threepop -i ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.treemix.gz -k 500
```

The four-population test is of the form f4(A;B;C;D), where a significantly negative value of the f4 statistic implies gene flow in the tree. The output is four columns: populations | f4 statistic | standard error | Z-score
```{bash run fourpop}
fourpop -i ${POPSTR}$VCFNAME.pass_noNA.high_anc_coef_snmf.treemix.gz -k 500
```



#Split tree
```{r subset even sampling}
#Subsample
temp = Zt_meta %>%
  filter(!(ID_file %in% filtered_samples$ID_file)) %>% 
  unite(Country, Region, col = "Country2", remove = F) %>%
  mutate(Country_for_filter = ifelse(Country == "USA", Country2, Country)) %>%
  mutate(x = round(Latitude, 1), y = round(Longitude, 1)) %>%
  unite(Coord_for_filter, x, y, sep = ";", remove = F) %>%
  group_by(Coord_for_filter) %>% 
  mutate(Nb_per_coord = n()) %>% 
  group_by(Country_for_filter) %>% 
  mutate(Nb_per_country= n())
  
small_pop = temp %>%
  filter(Nb_per_coord <= 15) %>%
  filter(Nb_per_country <= 60)

temp2 = bind_rows(temp %>%
                    filter(!(ID_file %in% small_pop$ID_file))%>%
                    filter(Nb_per_coord > 15) %>% 
                    group_by(Coord_for_filter) %>%
                    dplyr::sample_n(15),
                  temp %>%
                    filter(!(ID_file %in% small_pop$ID_file))%>%
                    filter(Nb_per_coord <= 15)) %>% 
        ungroup() %>%
        group_by(Country_for_filter) %>% 
        dplyr::mutate(Nb_per_country= n())

Zt_meta_even_sampling = bind_rows(temp2 %>% 
                    filter(Nb_per_country > 60) %>%
                    dplyr::sample_n(60),
                  temp2 %>% 
                    filter(Nb_per_country <= 60)) %>%
  bind_rows(., small_pop) %>%
  ungroup()


write_tsv(Zt_meta_even_sampling %>% dplyr::select(ID_file), 
          paste0(PopStr_dir, "List_samples_even_sampling.txt"),
          col_names = F)


ggplot() +
  geom_bar(data = temp %>% group_by(Continent, Country_for_filter) %>% dplyr::count(),
           aes(x= Country_for_filter, y = n, fill = Continent), alpha = 0.4, stat = "identity") +
  geom_bar(data = Zt_meta_even_sampling %>% group_by(Continent, Country_for_filter) %>% dplyr::count(),
           aes(x= Country_for_filter, y = n, fill = Continent), alpha = 0.4, stat = "identity") +
  Fill_Continent + theme_bw() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

  
```
```{bash vcftools even sampling}
head ${POPSTR}List_samples_even_sampling.txt

vcftools --vcf ${VCFDIR}$VCFNAME.recode.vcf \
  --keep ${POPSTR}List_samples_even_sampling.txt \
  --remove-filtered-all --extract-FORMAT-info GT \
  --max-missing 1.0 --min-alleles 2 --max-alleles 2 \
  --maf 0.05 \
  --out ${POPSTR}$VCFNAME.pass_noNA.even_sampling


cat  ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT | cut -f 3- \
    > ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT2
cat  ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT | cut -f 1,2 \
    > ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT.pos
head -n1 ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT2 | gsed "s/\t/\n/g"  \
    > ${POPSTR}$VCFNAME.pass_noNA.even_sampling.ind
gsed "s/\t//g"  ${POPSTR}$VCFNAME.pass_noNA.even_sampling.GT.FORMAT2 | tail -n +2 \
    > ${POPSTR}$VCFNAME.pass_noNA.even_sampling.geno
    
    
```



<br><br>



# Mitochondrial genome

##PCA with the mitochondrial genome
```{bash filter mito vcf, eval = F}
#sed $'s/\tDP_filter\t/\tPASS\t/' \
#  ../1_Variant_calling/4_Joint_calling/Ztritici_global_December2020.genotyped.mt.filtered.vcf > \
# ../1_Variant_calling/4_Joint_calling/Ztritici_global_December2020.genotyped.mt.filtered.reversed_depth_filter.vcf

vcftools --vcf ${VCFDIR}${VCFNAME_MITO}.vcf \
  --non-ref-ac-any 1 \
  --min-alleles 2 --max-alleles 2 \
  --remove-filtered-all --recode --recode-INFO-all \
  --out ${VCFDIR}${VCFNAME_MITO}.biall

```




```{r PCA mito run and plot, results = F}
snpgdsVCF2GDS(paste0(vcf_dir, vcf_name_mito, ".biall.recode.vcf"),
              paste0(PopStr_dir, vcf_name, ".biall.recode.gds"), method="biallelic.only")
genofile_mito <- snpgdsOpen(paste0(PopStr_dir, vcf_name, ".biall.recode.gds"))
pca_mito <-snpgdsPCA(genofile_mito, autosome.only=FALSE)
snpgdsClose(genofile_mito)

pca_mito2 = as_tibble(pca_mito$eigenvect) %>% dplyr::select(V1:V4)
colnames(pca_mito2) = c("PC1", "PC2", "PC3", "PC4")
pca_mito2 = pca_mito2 %>%
  dplyr::mutate(sample_id = pca_mito$sample.id ) %>%
  dplyr::right_join(., Zt_meta, by = c("sample_id" = "ID_file")) %>%
  unite(sample_id, Country, col = "for_display", remove = F) %>%
  filter(!is.na(PC1))

as.tibble(pca_mito$eigenval[!is.na(pca_mito$eigenval)]) %>%
  ggplot(aes(x = c(1:length(pca_mito$eigenval[!is.na(pca_mito$eigenval)])),
             y =value)) + geom_point() +
  theme_bw()


eigen_sum = sum(pca_mito$eigenval[!is.na(pca_mito$eigenval)])
p = ggplot(pca_mito2, aes(x = PC1, y= PC2, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(pca_mito$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 2 (", round(pca_mito$eigenval[2]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw() + theme(legend.position = "none")


q = ggplot(pca_mito2, aes(x = PC3, y= PC4, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 3 (", round(pca_mito$eigenval[3]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 4 (", round(pca_mito$eigenval[4]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw()+ theme(legend.position = "bottom")

cowplot::plot_grid(p, q, ncol = 1, rel_heights = c(1, 1.2))


#Let's make groups of samples from the PCA.
p +
  geom_vline(aes(xintercept = 0.03)) +
  geom_label(aes(x = 0, y = -0.03, label = "Mito_group = 1")) +
  geom_label(aes(x = 0.05, y = -0.03, label = "Mito_group = 0"))

pca_mito2 = pca_mito2 %>% 
  mutate(Mito_group = ifelse(PC1 > 0.03, "0", "1")) 

Nb_per_mito_group = pca_mito2 %>%
  group_by(Mito_group) %>%
  dplyr::count() %>% dplyr::select(Nb_per_group = n)

Nb_per_mito_group


#Write files for separating vcf files
pca_mito2 %>% 
  filter(Mito_group == "0") %>%
  dplyr::select(sample_id) %>%
  write_tsv(., paste0(mito_PS_dir, "Sample_list_mito_group0.txt"))

pca_mito2 %>% 
  filter(Mito_group == "1") %>%
  dplyr::select(sample_id) %>%
  write_tsv(., paste0(mito_PS_dir, "Sample_list_mito_group1.txt"))
```


Now that my groups are defined, I want to investigate the origin of this clustering. Is the variation homogeneously distributed along the mitochondrial genome? Are there areas with a higher differentiation between the two groups?
There are around 10 percent of the samples belong to group 0. I would thus expect that alleles that are shared between these samples and specific to these samples would have a minor allele frequency of around 0.1. 

```{bash MAF mito run, eval = F}
~/Documents/Software/bcftools/bcftools query \
  -f '%CHROM\t%POS\n' \
  ${VCFDIR}${VCFNAME_MITO}.biall.recode.vcf > \
  ${VCFDIR}${VCFNAME_MITO}.biall.positions

tail ${VCFDIR}${VCFNAME_MITO}.biall.positions

~/Documents/Software/bcftools/bcftools query \
  -f '%CHROM\t%POS\t%REF[\t%SAMPLE=%GT]\n' \
  ${VCFDIR}${VCFNAME_MITO}.biall.recode.vcf > \
  ${VCFDIR}${VCFNAME_MITO}.biall.genotypes
  
vcftools \
--vcf ${VCFDIR}${VCFNAME_MITO}.biall.recode.vcf \
--freq --min-alleles 2 --max-alleles 2 \
--out ${VCFDIR}${VCFNAME_MITO}.biall
```

```{r MAF mito}
#First let's look at the distribution of SNPs and the maf 
temp = read_tsv(paste0(vcf_dir, vcf_name_mito, ".clean.good_samples.positions"), 
                          col_names = c("CHROM", "POS")) %>%
  mutate(window = trunc(POS/1000)*1000)

mito_positions = read_tsv(paste0(vcf_dir, vcf_name_mito, ".clean.good_samples.frq"), col_names = T) %>%
  separate(`{ALLELE:FREQ}`, into = c("ALLELE", "FREQ"), sep = ":") %>%
  mutate(rev_FREQ = 1-as.numeric(FREQ)) %>%
  group_by(POS) %>%
  mutate(maf = min(rev_FREQ, FREQ)) %>%
  full_join(., temp) %>%
  ungroup()

mito_positions %>%
  ggplot(aes(x = POS, y = as.numeric(maf)))+ 
    theme_bw() + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=0.5, 
           alpha=0.4, fill=blues[[4]]) + 
    geom_point() +
  labs(x = "Position along the mitochondrial genome",
       y = "Minor allele frequency",
       title = "Distribution of variants and MAF along the mitochondria",
       subtitle = str_wrap(paste0("One region surrounding the cytb gene (shaded in blue) ",
                                  "contains a lot of variants with the same MAF.")))


# Looking at the genotypes for all samples: 
# are there loci where the two groups contain different alleles?
temp = read_tsv(paste0(vcf_dir, vcf_name_mito, ".clean.good_samples.genotypes"), 
                          col_names = F) %>%
  pivot_longer(-c(X1, X2, X3)) %>%
  separate(value, into=c("sample_id", "Genotype"), sep = "=") %>%
  dplyr::select(CHROM = X1, POS = X2, REF = X3, sample_id, Genotype) %>%
  #pivot_wider(names_from = sample_id, values_from = Genotype) %>%
  filter(POS > 0) %>%
  filter(POS < 46000) 

temp = temp %>%
  inner_join(., pca_mito2) %>%
  full_join(., Nb_per_mito_group)

 temp %>% 
  group_by(Mito_group, POS,Nb_per_group) %>%
  dplyr::count(Genotype) %>%
  mutate(Freq = n/Nb_per_group) %>%
  filter(Genotype == 1 | Genotype == 0)  %>%
  ggplot(aes(x = POS, y = Freq, color = Mito_group)) + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=1, 
           alpha=0.3, fill=blues[[4]]) +
  geom_point(alpha = 0.5) +
  theme_bw() + 
  facet_grid(vars(Genotype)) +
   labs(title = "Frequency of alleles in the two mitocondrial groups",
        subtitles = "The locus with a stable MAF at 0.1 seems to correspond to group 0-specific alleles.")

```

I strongly suspect that the locus of high differentiation observed around the cytb gene is responsible for most if not all of the clustering signal in the PCA. To check this, I will run a PCA again but this time filtering the SNPs between the positions 25500 and 30000, thus effectively erasing all signal from this particular locus.
```{bash mito filter high diff, eval = F}
echo "#chrom chromStart  chromEnd" > ${VCFDIR}${VCFNAME_MITO}_positions_to_exclude.bed
echo "mt  25500 30000" >> ${VCFDIR}${VCFNAME_MITO}_positions_to_exclude.bed

vcftools --vcf ${VCFDIR}${VCFNAME_MITO}.vcf \
  --keep $ZTLIST \
  --non-ref-ac-any 1 \
  --min-alleles 2 --max-alleles 2 \
  --remove-filtered-all --recode --recode-INFO-all \
  --exclude-bed  ${VCFDIR}${VCFNAME_MITO}_positions_to_exclude.bed \
  --out ${VCFDIR}${VCFNAME_MITO}.clean.good_samples.no_high_diff_region
```



```{r PCA mito wo high diff, results = F}
snpgdsVCF2GDS(paste0(vcf_dir, vcf_name_mito, ".clean.good_samples.no_high_diff_region.recode.vcf"),
              paste0(PopStr_dir, vcf_name, ".clean.good_samples.no_high_diff_region.recode.gds"),
              method="biallelic.only")
genofile_mito_wo_diff <- snpgdsOpen(paste0(PopStr_dir, vcf_name, 
                                   ".clean.good_samples.no_high_diff_region.recode.gds"))
pca_mito_wo_diff <-snpgdsPCA(genofile_mito_wo_diff, autosome.only=FALSE)
snpgdsClose(genofile_mito_wo_diff)

pca_mito_wo_diff2 = as_tibble(pca_mito_wo_diff$eigenvect) %>% dplyr::select(V1:V4)
colnames(pca_mito_wo_diff2) = c("PC1", "PC2", "PC3", "PC4")
pca_mito_wo_diff2 = pca_mito_wo_diff2 %>%
  dplyr::mutate(sample_id = pca_mito_wo_diff$sample.id ) %>%
  dplyr::right_join(., Zt_meta, by = c("sample_id" = "ID_file")) %>%
  unite(sample_id, Country, col = "for_display", remove = F) %>%
  filter(!is.na(PC1))

as.tibble(pca_mito_wo_diff$eigenval[!is.na(pca_mito_wo_diff$eigenval)]) %>%
  ggplot(aes(x = c(1:length(pca_mito_wo_diff$eigenval[!is.na(pca_mito_wo_diff$eigenval)])),
             y =value)) + geom_point() +
  theme_bw()


eigen_sum = sum(pca_mito_wo_diff$eigenval[!is.na(pca_mito_wo_diff$eigenval)])
p = pca_mito2 %>%
  dplyr::select(sample_id, Mito_group) %>%
  full_join(., pca_mito_wo_diff2) %>%
  ggplot(aes(x = PC1, y= PC2, text = for_display)) +
  geom_point(aes(color = Continent, shape = Mito_group)) +
  labs(x = paste0("PC 1 (", round(pca_mito_wo_diff$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 2 (", round(pca_mito_wo_diff$eigenval[2]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw()

p + labs(title = "PCA from the mitochondrial genome of *Z.tritici*",
         subtitle = "Without the SNPs between the positions 25500 and 30000") +
  theme(plot.title = ggtext::element_markdown())

```

As a note, there does not seem to be a clear relationship between the known mutation G143A in the cytb gene and these two groups.

At first glance, it does not look like the structure is related to geography, but I want to compare the structure obtained with both types of genomes to get a clearer idea of the comparison.

```{r mito vs nuclear str}
p = pca_mito2 %>%
  dplyr::select(PC1_mito = PC1, PC2_mito = PC2, for_display) %>%
  full_join(., pca2) %>%
  full_join(., high_anc_coef_snmf %>% dplyr::select(-for_display)) %>%
  ggplot(aes(x = PC1, y= PC1_mito, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 nuclear genome (", round(pca$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 1 mitochondrial genome (", round(pca_mito$eigenval[1]*100/eigen_sum, 2), "%)"),
       title = "Comparison between the PC1 for the nuclear and mitochondrial genomes") +
  Color_Continent +
  theme_bw() 

p

temp = pca_mito2 %>%
  dplyr::select(Sample = sample_id, Mito_group) %>%
  full_join(., high_anc_coef_snmf) %>%
  group_by(Mito_group, Cluster) %>%
  dplyr::count() 
temp2 = temp %>% 
  pivot_wider(names_from = Mito_group, values_from = n) %>%
  mutate(`0` = ifelse(is.na(`0`), 0, `0`)) %>%
  mutate(total = (`0` + `1`), 
         Percent = paste0(round(100*`0`/(`0` + `1`), 2), "%"))

p = temp %>%
  ggplot(aes(x = Cluster, y=n)) +
  geom_bar(aes(fill = Mito_group), stat = "identity")  +
  theme_bw() + 
  geom_text(data = temp2, aes(x = Cluster, y = total + 10, label = Percent),  size=3.5) +
  scale_fill_manual(values = c(unname(myColors)[1], unname(myColors)[3])) +
  labs(title = str_wrap(paste0("Number of samples belonging to the two mitochondrial",
                               " groups per nuclear genetic cluster"), width = 60))
p


```
The proportions of the mitochondrial haplotypes across the genetic clusters defined with the nuclear genome is not equal: some clusters have only one mitochondrial group, while some others are 50/50. Not sure what to make of it.


I got curious about the distance from each mitochondrial haplotype to the wild species. So I picked one isolate from each group, including IPO323 as an example of the mitogroup 1. 
```{r mito Zb}
temp = bind_rows(read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/Za.B01_vs_SRR5194479.snps", 
         col_names = F),
         read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/Za.B01_vs_IPO323.snps", 
                  col_names = F)) %>%
  mutate(window = round(X1/100)*100)


IPO323_windows = temp %>% 
  filter(X12 ==  "mt") %>%
  dplyr::select(X1, X2, X4) %>%
  mutate(IPO323_window = round(X4/100)*100) %>%
  dplyr::select(-X4)


p1 = full_join(temp, IPO323_windows) %>%
  group_by(IPO323_window, X12) %>%
  dplyr::count() %>%
  ggplot(aes(x = IPO323_window, y = n, col = X12)) +
  geom_point(alpha = 0.4)  +
  geom_line(alpha = 0.4) + 
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(y = "Distance from Zb (#variants)",
       col = "Group") + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=200, 
           alpha=0.4, fill=blues[[4]])

p2 = full_join(temp, IPO323_windows) %>%
  group_by(IPO323_window, X12) %>%
  dplyr::count() %>% ungroup() %>%
  pivot_wider(names_from = X12, values_from = n) %>%
  mutate(diff = mt - scaf182) %>%
  ggplot(aes(x = IPO323_window, y = diff)) +
  geom_point(alpha = 0.4)  + 
  theme_bw() +
  labs( y = "Difference between distances from Zb (#variants)") + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=6, 
           alpha=0.4, fill=blues[[4]])
cowplot::plot_grid(p1, p2, ncol = 1, rel_heights = c(1.4, 1))

full_join(temp, IPO323_windows) %>%
  group_by(IPO323_window, X12) %>%
  dplyr::count() %>%
  filter(IPO323_window > 20000 & IPO323_window < 30000 ) %>%
  ggplot(aes(x = IPO323_window, y = n, col = X12)) +
  geom_point(alpha = 0.4)  +
  geom_line(alpha = 0.4) + 
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(y = "Distance from Zb (#variants)",
       col = "Group") + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=200, 
           alpha=0.4, fill=blues[[4]])


bind_rows(read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/IPO323_vs_SRR5194479_.snps", 
                  col_names = F) %>% mutate(X12 = "Mitogroup0"),
read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/IPO323_vs_SRR5194475.snps", 
                  col_names = F)%>% mutate(X12 = "Mitogroup1")) %>%
  mutate(window = round(X1/100)*100)%>%
  group_by(window, X12) %>%
  dplyr::count() %>%
  ggplot(aes(x = window, y = n, col = X12)) +
  geom_point(alpha = 0.4)  +
  geom_line(alpha = 0.4) + 
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(y = "Distance from IPO323 (#variants)",
       col = "Group") + 
  annotate("rect", 
           xmin=26989, xmax=28160, 
           ymin=0, ymax=20, 
           alpha=0.4, fill=blues[[4]])
```




### Check of the validity of the variant calling

The whole two-group thing look very strange. So I decided to do some checks of the validity of variants around the region of interest.
```{bash inputs per mitogroup, eval = F}
for x in 0 1 ; 
do 

#VCF with only variants within groups
vcftools --vcf ${VCFDIR}${VCFNAME_MITO}.vcf \
  --keep ${MITOPOPSTR}Sample_list_mito_group${x}.txt \
  --non-ref-ac-any 1 \
  --min-alleles 2 --max-alleles 2 \
  --remove-filtered-all --recode --recode-INFO-all \
  --out ${MITOPOPSTR}${VCFNAME_MITO}.mito_group${x}
  
#VCF with all positions but within group samples only
vcftools --vcf ${VCFDIR}${VCFNAME_MITO}.vcf \
  --keep ${MITOPOPSTR}Sample_list_mito_group${x}.txt \
  --recode --recode-INFO-all \
  --out ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}
 
#Depth per group
vcftools --vcf ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}.recode.vcf \
  --site-depth \
  --out ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}

# Allelic freq per group
vcftools --vcf ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}.recode.vcf \
  --freq --min-alleles 2 --max-alleles 2 \
  --out ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}
  
#Genotypes for all samples for each group
/Users/feurtey/Documents/Software/bcftools/bcftools query \
  -f '%CHROM\t%POS[\t%AD]\n' \
  ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}.recode.vcf \
   > ${MITOPOPSTR}${VCFNAME_MITO}.ALL_POS.mito_group${x}.AD.tsv
   
 done
```

For a start, I want to look at the depth, both for per genotype and then per allele. The first is to detect a potential duplication of the region of interest which would lead to SNPs being called in this region when in reality, the reads belongs to paralogs. The second is to check for heteroplasticity: do cells contain the two haplotypes?
```{r}
#Depth in general
temp = bind_rows(read_tsv(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group1.ldepth")) %>%
mutate(Mito_group = 1),
read_tsv(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group0.ldepth")) %>%
mutate(Mito_group = 0))

mean_depth = temp %>% 
  dplyr::group_by(Mito_group) %>% 
  dplyr::summarize(average = mean(SUM_DEPTH))

temp = left_join(temp, mean_depth) %>% 
  mutate(norm_site_depth = SUM_DEPTH/average)

y_lim = max(temp$norm_site_depth)
p1 = ggplot(temp, aes(x = POS, y = norm_site_depth, col = Mito_group)) +
    annotate("rect", alpha=0.3, fill=blues[[4]],
           xmin=28000, xmax=30000, ymin=0, ymax=y_lim) +
  geom_point(alpha = 0.4) +
  theme_bw() + 
  labs(title = "Depth per mito group along the mt genome",
       x = "Position",
       y= "Normalized read depth")



#Allelic depth

temp = bind_rows(read.delim(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group0.AD.tsv"), 
                            header = F) %>% mutate(Mito_group = 0) %>%
    pivot_longer(cols = -c(V1, V2, Mito_group), names_to ="Sample", values_to = "AD") , 
                 read.delim(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group1.AD.tsv"), 
                            header = F) %>% mutate(Mito_group = 1)%>%
    pivot_longer(cols = -c(V1, V2, Mito_group), names_to ="Sample", values_to = "AD") ) %>%
  filter(str_count(AD, ",") == 1) %>%
    separate(AD, into = c("REF", "ALT"), sep = ",") %>%
    group_by(V2, Mito_group, Sample, V1) %>%
    mutate(ratio = min(as.numeric(REF),as.numeric(ALT)) / (as.numeric(REF) + as.numeric(ALT)))


temp2 = temp %>%
  group_by(V2, Mito_group) %>%
  summarize(ave_ratio = mean(ratio)) 

y_lim = max(temp2$ave_ratio, na.rm = T)

p2 = ggplot(temp2, aes(x = V2, y = ave_ratio, col = Mito_group)) + 
  annotate("rect", alpha=0.3, fill=blues[[4]],
           xmin=28000, xmax=30000, ymin=0, ymax=y_lim) +
  labs(y = "Ratio of maf/(all depth)", 
       title = "Ratio of allelic depth: heteroplasmy should lead to higher ratios", 
       x = "Position") +
    geom_point(alpha = 0.4) +
    theme_bw()

cowplot::plot_grid(p1, p2, ncol = 1)
```


The depth looks a bit strange around of region of interest. But the ratio of allelic depth does not seem to fit with the possibility of heteroplastic mitochondria. 


In order to check further if the variants could be erroneously called around a structural variation of some type that the mapping + SNP calling would be confused by, I want to see if I can recover the  variants in pairwise alignments between the reference mitochondria and assembled mitochondria from the resequencing. To limit problems due to low quality assemblies or alignments, I only use the mitochondrial genomes which are completely assembled, i.e. a contig which represent 90% of the length aligned to the mitochondria in the assembly and is longer than 30kb. 


```{r}
#Rewrite and/or check!
# Mitogroup + complete
complete_mito = pca_mito2 %>%
  dplyr::select(sample_id, Mito_group) %>%
  inner_join(., complete_mito)

nb_complete_mito_per_group = as.data.frame(table(complete_mito$Mito_group))
names(nb_complete_mito_per_group) = c("Mito_group", "Total_nb")
nb_complete_mito_per_group
```


On the cluster, I extract these identified mitochondrial genomes from the whole assemblies and align them using dnadiff from mummer. 

WARN: the frequencies calculated on the GATK dataset are not based on the same set of samples as the other other one since it includes all good quality samples and not just the ones with complete mitochondria.
```{r comparison SNP mito}

#Output of dna_diff in terms of snps
snps_from_aln = read_tsv(paste0(mito_SV, "All_complete_mitochondria.snps")) %>%
  mutate(TEMP = gsub("_scaf", ":scaf", scaf)) %>%
  separate(TEMP, into = c("sample_id", "scaffold"), sep = ":") %>%
  dplyr::select(CHROM, POS, REF, ALT, sample_id) %>%
  left_join(., pca_mito2 %>% dplyr::select(sample_id, Mito_group)) #%>%
  #pivot_wider(names_from = sample_id, values_from = ALT)
rm(snps_list) 

snps_from_aln %>%
  mutate(window = round(POS/100)) %>%
  group_by(sample_id, window) %>%
  dplyr::count() %>%
  inner_join(pca_mito2 %>% dplyr::select(sample_id, Mito_group), .) %>%
  group_by(Mito_group, window) %>%
  summarize(ave_SNP_nb = mean(n)) %>%
  ggplot(aes(x = window, y = ave_SNP_nb, col = Mito_group)) + 
  geom_point() + theme_bw()

#Looking at the frequencies in the GATK SNP calling
Freq_mito_per_group = bind_rows(read_tsv(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group0.frq")) %>%
  mutate(Mito_group = 0),
  read_tsv(paste0(mito_PS_dir, vcf_name_mito, ".ALL_POS.mito_group1.frq")) %>%
  mutate(Mito_group = 1)) %>% 
  separate(`{ALLELE:FREQ}`, into = c("ALLELE", "FREQ"), sep = ":") %>%
  dplyr::select(-N_CHR, -N_ALLELES) %>%
  pivot_wider(values_from = FREQ, names_from = Mito_group) %>%
  mutate(Diff_freq_in_GATK = as.numeric(`0`) - as.numeric(`1`))

ggplot(Freq_mito_per_group, aes(x = POS, y =Diff_freq_in_GATK)) +
  geom_point() +theme_bw()

#Comparing the presence of SNPs with high differenciation between the two groups
check_relevant_SNPS = snps_from_aln %>% group_by(Mito_group, POS) %>% 
  dplyr::count() %>%
  left_join(., nb_complete_mito_per_group) %>% 
  mutate(Freq_non_ref = n/Total_nb) %>% 
  pivot_wider(names_from = Mito_group, values_from = Freq_non_ref) %>%
  dplyr::select(POS, Freq_var0_aln = `0`, Freq_var1_aln = `1`) %>% 
  mutate(Freq_var0_aln = ifelse(is.na(Freq_var0_aln), 0, Freq_var0_aln),
         Freq_var1_aln = ifelse(is.na(Freq_var1_aln), 0, Freq_var1_aln),
         Diff_freq_in_aln = Freq_var0_aln - Freq_var1_aln) %>%
  left_join(Freq_mito_per_group, .) %>%
  filter(abs(Diff_freq_in_GATK) > 0.8)
check_relevant_SNPS

#To repeat with the exact same samples!
#snps_from_aln %>% group_by(Mito_group, POS) %>% 
#  dplyr::count() %>%
#  left_join(., nb_complete_mito_per_group) %>% 
#  mutate(Freq_non_ref = n/Total_nb) %>% 
#  pivot_wider(names_from = Mito_group, values_from = Freq_non_ref) %>%
#  dplyr::select(POS, Freq_var0_aln = `0`, Freq_var1_aln = `1`) %>% 
#  mutate(Freq_var0_aln = ifelse(is.na(Freq_var0_aln), 0, Freq_var0_aln),
#         Freq_var1_aln = ifelse(is.na(Freq_var1_aln), 0, Freq_var1_aln),
#         Diff_freq_in_aln = Freq_var0_aln - Freq_var1_aln) %>%
#  left_join(Freq_mito_per_group, .) %>%
#  ggplot(aes(x = Diff_freq_in_GATK, y = Diff_freq_in_aln)) +
#  geom_point()
```
The SNPs we are interested in are indeed found using both methods.

```{r}
temp = read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/IPO323_vs_Zp.B02.snps", 
         col_names = c("POS", "REF", "Zp", "Ref", "Whatever",
                       "V1", "V2", "V3", "V4", "V5", "CHROM", "scaf"))

alleles = inner_join(snps_from_aln, check_relevant_SNPS %>% dplyr::select(CHROM, POS)) %>%
  filter(Mito_group == 0) %>%
   group_by(POS, ALT) %>%
  dplyr::count() %>%
  pivot_wider(names_from = ALT, values_from = n) %>%
  left_join(., temp %>% dplyr::select(Zp, POS))

temp = read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/IPO323_vs_Zb.B01.snps", 
         col_names = c("POS", "REF", "Zb", "Ref", "Whatever",
                       "V1", "V2", "V3", "V4", "V5", "CHROM", "scaf"))

alleles = alleles %>%
  left_join(., temp %>% dplyr::select(Zb, POS))


temp = read_tsv("/Users/feurtey/Documents/Software/mummer-4.0.0rc1/IPO323_vs_Za.B01.snps", 
         col_names = c("POS", "REF", "Za", "Ref", "Whatever",
                       "V1", "V2", "V3", "V4", "V5", "CHROM", "scaf"))
alleles = alleles %>%
  left_join(., temp %>% dplyr::select(Za, POS))


```



Now that the SNPs are compared and confirmed, I want to look at the structural variants and in particular break points in the alignment between the genomes and the mitochondria of the reference strain.

```{r breaks mito}
#Gathered on the cluster and imported as such
coords_from_aln = read_tsv(paste0(mito_SV, "All_complete_mitochondria.mcoords")) %>%
  mutate(TEMP = gsub("_scaf", ":scaf", scaf)) %>%
  separate(TEMP, into = c("sample_id", "scaffold"), sep = ":") %>%
  left_join(., pca_mito2 %>% dplyr::select(sample_id, Mito_group)) 

temp = coords_from_aln %>%
  dplyr::select(Mito_group, Ref_start, Ref_end, sample_id) %>%
  group_by(Mito_group, Ref_start) %>%
  dplyr::count() %>%
  left_join(., nb_complete_mito_per_group) %>% 
  mutate(Freq_break = n/Total_nb) %>%
  pivot_wider(names_from = Mito_group, values_from = Freq_break) %>%
  dplyr::select(Ref_start, Freq_break0 = `0`, Freq_break1 = `1`) %>% 
  mutate(Freq_break0 = ifelse(is.na(Freq_break0), 0, Freq_break0),
         Freq_break1 = ifelse(is.na(Freq_break1), 0, Freq_break1),
         Diff_freq_in_breaks = Freq_break0 - Freq_break1,
         More_freq_in_0 = Diff_freq_in_breaks >= 0) 

temp %>% ggplot(aes(x = Ref_start, y = Diff_freq_in_breaks, 
                    col = More_freq_in_0, alpha = abs(Diff_freq_in_breaks) + 0.01)) +
  geom_point() + 
  theme_bw() +
  scale_color_manual(values = c(unname(myColors)[3], unname(myColors)[1])) +
  labs(title = "Difference in frequency of breakpoints between the two mito_groups",
       subtitle = str_wrap(paste0("Two breakpoints seem to be found in",
                                  "all genomes from group 0, including one ",
                                  "in the region of interest.")),
       alpha = "Difference intensity",
       col = "Breakpoint more frequent in group 0",
       x = "Position on the mitochondrial genome",
       y = "Difference in frequency") +
  theme(legend.position = "bottom")
  
```



### Structure per mito group

```{r PCA per mito group}
## Mito group 0
snpgdsVCF2GDS(paste0(mito_PS_dir, vcf_name_mito, ".mito_group0.recode.vcf"),
              paste0(mito_PS_dir, vcf_name, ".mito_group0.recode.gds"),
              method="biallelic.only")
genofile_mito_gp0 <- snpgdsOpen(paste0(mito_PS_dir, vcf_name, 
                                   ".mito_group0.recode.gds"))
pca_mito_gp0 <-snpgdsPCA(genofile_mito_gp0, autosome.only=FALSE)
snpgdsClose(genofile_mito_gp0)

pca_mito_gp0_2 = as_tibble(pca_mito_gp0$eigenvect) %>% dplyr::select(V1:V4)
colnames(pca_mito_gp0_2) = c("PC1", "PC2", "PC3", "PC4")
pca_mito_gp0_2 = pca_mito_gp0_2 %>%
  dplyr::mutate(sample_id = pca_mito_gp0$sample.id ) %>%
  dplyr::right_join(., Zt_meta, by = c("sample_id" = "ID_file")) %>%
  unite(sample_id, Country, col = "for_display", remove = F) %>%
  filter(!is.na(PC1))

as.tibble(pca_mito_gp0$eigenval[!is.na(pca_mito_gp0$eigenval)]) %>%
  ggplot(aes(x = c(1:length(pca_mito_gp0$eigenval[!is.na(pca_mito_gp0$eigenval)])),
             y =value)) + geom_point() +
  theme_bw()


eigen_sum = sum(pca_mito_gp0$eigenval[!is.na(pca_mito_gp0$eigenval)])
p = pca_mito_gp0_2 %>%
  ggplot(aes(x = PC1, y= PC2, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(pca_mito_gp0$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 2 (", round(pca_mito_gp0$eigenval[2]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw() + 
  labs(title = "PCA from the mitochondrial genome of *Z.tritici*",
         subtitle = "Only mito group 0") +
  theme(plot.title = ggtext::element_markdown(),
        legend.position = "none")
p2 = pca_mito_gp0_2 %>%
  ggplot(aes(x = PC3, y= PC4, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 3 (", round(pca_mito_gp0$eigenval[3]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 4 (", round(pca_mito_gp0$eigenval[4]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw() +
  theme(plot.title = ggtext::element_markdown(),
        legend.position = "bottom")

cowplot::plot_grid(p, p2, ncol = 1)


## Mito group 1
snpgdsVCF2GDS(paste0(mito_PS_dir, vcf_name_mito, ".mito_group1.recode.vcf"),
              paste0(mito_PS_dir, vcf_name, ".mito_group1.recode.gds"),
              method="biallelic.only")
genofile_mito_gp1 <- snpgdsOpen(paste0(mito_PS_dir, vcf_name, 
                                   ".mito_group1.recode.gds"))
pca_mito_gp1 <-snpgdsPCA(genofile_mito_gp1, autosome.only=FALSE)
snpgdsClose(genofile_mito_gp1)

pca_mito_gp1_2 = as_tibble(pca_mito_gp1$eigenvect) %>% dplyr::select(V1:V4)
colnames(pca_mito_gp1_2) = c("PC1", "PC2", "PC3", "PC4")
pca_mito_gp1_2 = pca_mito_gp1_2 %>%
  dplyr::mutate(sample_id = pca_mito_gp1$sample.id ) %>%
  dplyr::right_join(., Zt_meta, by = c("sample_id" = "ID_file")) %>%
  unite(sample_id, Country, col = "for_display", remove = F) %>%
  filter(!is.na(PC1))

as.tibble(pca_mito_gp1$eigenval[!is.na(pca_mito_gp1$eigenval)]) %>%
  ggplot(aes(x = c(1:length(pca_mito_gp1$eigenval[!is.na(pca_mito_gp1$eigenval)])),
             y =value)) + geom_point() +
  theme_bw()


eigen_sum = sum(pca_mito_gp1$eigenval[!is.na(pca_mito_gp1$eigenval)])
p = pca_mito_gp1_2 %>%
  ggplot(aes(x = PC1, y= PC2, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 1 (", round(pca_mito_gp1$eigenval[1]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 2 (", round(pca_mito_gp1$eigenval[2]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw() + 
  labs(title = "PCA from the mitochondrial genome of *Z.tritici*",
         subtitle = "Only mito group 1") +
  theme(plot.title = ggtext::element_markdown(),
        legend.position = "none")
p2 = pca_mito_gp1_2 %>%
  ggplot(aes(x = PC3, y= PC4, text = for_display)) +
  geom_point(aes(color = Continent)) +
  labs(x = paste0("PC 3 (", round(pca_mito_gp1$eigenval[3]*100/eigen_sum, 2), "%)"),
       y = paste0("PC 4 (", round(pca_mito_gp1$eigenval[4]*100/eigen_sum, 2), "%)")) +
  Color_Continent +
  theme_bw() +
  theme(plot.title = ggtext::element_markdown(),
        legend.position = "bottom")

cowplot::plot_grid(p, p2, ncol = 1)

```
It could have been expected that the geographical structure would be very clear once we separate the two groups. Although this is not the case, we can still recover part of a geographical separation in the group with most genomes.



```{r mito vs pheno}

phenotypes = read_tsv(paste0(project_dir, "Phenotypes/Anik_2020_phenotypes.tsv")) %>%
  mutate(POP = str_sub(sample_id, 1, 6)) %>%
  inner_join(pca_mito2 %>% dplyr::select(sample_id, Mito_group), .) %>% 
  dplyr::select(-MSR) %>%
  pivot_longer(cols = -c(sample_id, Mito_group, POP), names_to = "Phenotype", values_to = "Measure") 

table(phenotypes$POP, phenotypes$Mito_group)

list_phenotypes = phenotypes %>%
  dplyr::select(Phenotype) %>% unique() %>% pull()

signif_mito_phenotype <- as.data.frame(matrix(NA, length(list_phenotypes), 2))
names(signif_mito_phenotype) <- c("Phenotype", "p-value")
for(i in c(1:length(list_phenotypes))) {
  pheno = list_phenotypes[i]
  temp = phenotypes %>%
  filter(Phenotype == pheno)
  res.aov3 <- aov(Measure ~ POP + Mito_group + POP:Mito_group, data = temp)
  print(summary(res.aov3))
  signif_mito_phenotype[i, 1] = pheno
  signif_mito_phenotype[i, 2] = summary(res.aov3)[[1]][["Pr(>F)"]][[2]]
  print(c(pheno, summary(res.aov3)[[1]][["Pr(>F)"]][[2]]))
}

phenotypes %>%
  left_join(signif_mito_phenotype, .) %>%
  filter(`p-value` < 0.05) %>%
  filter(POP %in% c("ST01AU", "ST92IS")) %>%
  ggplot(aes(Mito_group, Measure, col = Mito_group)) +
  geom_boxplot() + 
  theme_bw() +
  facet_grid(Phenotype ~ POP, scales = "free_y")
```


<br><br>


# Basic statistics: diversity and differenciation
***

## Summary statistics

```{bash}
/Users/feurtey/Documents/Software/vcftools_jydu/src/cpp/vcftools \
  --vcf 
```


As of July 2020, this is done on the thinned vcf file. The part for the SFS is fine in this way. But the statistics should be run on the whole filtered vcf file instead. At least the code is ready.

```{bash prep for PopGenome, eval = F}
mkdir ${SUMST}PopGenome_splitchr
mkdir ${SUMST}PopGenome_splitchr/vcf
mkdir ${SUMST}PopGenome_splitchr/gff
mkdir ${SUMST}PopGenome_splitchr/fasta

cd ${SUMST}PopGenome_splitchr

# split into individual chromosome files starting form a complete vcf that contains exactly the loci you want
java -jar /Users/feurtey/Documents/Software/snpEff/SnpSift.jar \
    split ${VCFDIR}${VCFNAME_NOMAF}.recode.vcf

# create directories named after each vcf file, moves each file into its own folder
for x in {1..21} ;
do
  mkdir vcf/$x
  mv ${VCFDIR}${VCFNAME_NOMAF}.recode.${x}.vcf vcf/${x}/${x}.vcf

  mkdir gff/$x
  grep "^${x}\t" ${GFFFILE} > ${SUMST}PopGenome_splitchr/gff/${x}/${x}.gff

~/Documents/Software/samtools-1.10/samtools faidx \
   ${REFFILE} ${x} > fasta/${x}.fa

done
```


```{r PopGenome whole genome, message = F, warning = F, results = F}

# collect the set of chromosomes to process by scanning the vcf folders
Pop_vcf_dir = paste0(Sumstats_dir, "PopGenome_splitchr/vcf/")
Pop_gff_dir = paste0(Sumstats_dir, "PopGenome_splitchr/gff/")
Pop_ref_dir = paste0(Sumstats_dir, "PopGenome_splitchr/fasta/")

### Define population structure (can even be overlapping among groups if this is necessary)
# define individuals per pop (here it includes also a group that comprises all)

V1 <- as.character(high_anc_coef_snmf %>%
  filter(Cluster == "V1") %>%
  pull(Sample))
V2 <- high_anc_coef_snmf %>%
  filter(Cluster == "V2") %>%
  pull(Sample)
V3 <- high_anc_coef_snmf %>%
  filter(Cluster == "V3") %>%
  pull(Sample)
V4 <- high_anc_coef_snmf %>%
  filter(Cluster == "V4") %>%
  pull(Sample)
V5 <- high_anc_coef_snmf %>%
  filter(Cluster == "V5") %>%
  pull(Sample)
V6 <- high_anc_coef_snmf %>%
  filter(Cluster == "V6") %>%
  pull(Sample)

chr_vec <- system(paste0("ls ", Pop_vcf_dir), intern=T)
PopGenome_results_list = list()
syn_PopGenome_results_list = list()
# use this line below for testing (without running a loop)
#chr <- chr_vec[1]

### Looping through each chromosome, generate and record all statistics

for (chr in chr_vec) {
  # tryCatch aborts the current loop if the "if" statement throws an error (to avoid processing an empty gff file). An empty gff could occur if the current chromosome lacks any annotated genes/features
  tryCatch({

      info <- file.info(paste0(Sumstats_dir, "PopGenome_splitchr/gff/", chr,"/", chr,".gff"))[,"size"]
      if (info==0) stop(paste("No genes on chr", chr,"- skipping!"))

      ### define paths and load data
      vcf.path <- paste0(Pop_vcf_dir, chr)
      gff.path <- paste0(Pop_gff_dir, chr)
      GENOME.class <- readData(vcf.path, format="VCF", include.unknown=TRUE, gffpath=gff.path)
      all <- unlist(get.individuals(GENOME.class))

      # check how many SNPs were loaded using
      GENOME.class@n.biallelic.sites



      # Important: the output only refers to pop1, pop2, pop3 instead of the listed pops below. You must record the correct order of pop names
      GENOME.class <- set.populations(GENOME.class, list(all, V1, V2, V3, V4, V5, V6), diploid = FALSE)
      GENOME.class <- set.synnonsyn(GENOME.class, ref.chr=paste0(Pop_ref_dir, chr,".fa"),save.codons=TRUE)

      # estimate pairwise Fst and creates a slightly more convenient format
      GENOME.class <- F_ST.stats(GENOME.class, mode="nucleotide")
      pairwise.FST <- t(GENOME.class@nuc.F_ST.pairwise)
      pairwise.FST <- as.data.frame(GENOME.class@nuc.F_ST.pairwise) %>%
        mutate(pops = rownames(GENOME.class@nuc.F_ST.pairwise)) %>%
        separate(pops, into = c("Pop1", "Pop2"), sep = "/")
      results = data.frame(CHROM = chr,
                           position = GENOME.class@region.data@biallelic.sites,
                           CodingSNPS = GENOME.class@region.data@CodingSNPS[[1]],
                           synonymous = GENOME.class@region.data@synonymous[[1]],
                           ExonSNPS = GENOME.class@region.data@ExonSNPS[[1]])
      colnames(results) = c("#CHROM", "POS", "CodingSNPS", "synonymous", "ExonSNPS")

      PopGenome_results_list[[chr]] = results


      #Getting statistics from the synonymous positions
      GENOME.class.syn <- neutrality.stats(GENOME.class,subsites="syn")
      GENOME.class.syn  <- diversity.stats(GENOME.class.syn,subsites="syn")

      data.Number_SNPs <- data.frame(GENOME.class.syn@n.segregating.sites, statistic="Number_SNPs", chromosome = chr)
      data.TajD <- data.frame(GENOME.class.syn@Tajima.D,
                              statistic="TajimaD", chromosome = chr)
      data.theta <- data.frame(GENOME.class.syn@theta_Watterson,
                               statistic="theta_Watterson", chromosome = chr)
      data.Nucl_div <- data.frame(GENOME.class.syn@nuc.diversity.within,
                                  statistic="Nuc_Div", chromosome = chr)
      data.Nucl_div_per_site <- data.frame(GENOME.class.syn@nuc.diversity.within/GENOME.class.syn@n.sites,
                                           statistic="Nuc_Div_per_site", chromosome = chr)


      data.full <- rbind(data.Number_SNPs, data.theta,
                         data.TajD, data.Nucl_div, data.Nucl_div_per_site)


      syn_PopGenome_results_list[[chr]] = data.full
  # used to abort loop
  }, error=function(e){})
}   

PopGenome_results_whole = bind_rows(PopGenome_results_list)

PopGenome_results_whole %>%
  filter(synonymous == 1) %>%
  dplyr::select(`#CHROM`, POS) %>%
  write_tsv(paste0(Sumstats_dir, "Synonymous_SNPs.list.txt"), col_names = F)

syn_PopGenome_results_per_chr = bind_rows(syn_PopGenome_results_list) %>%
  na_if(., "NaN") %>%
  dplyr::mutate_at(vars(starts_with("pop")), funs(as.numeric)) %>%
  pivot_longer(-c(statistic, chromosome), names_to = "Population", values_to = "Estimate")

```

```{r Popgenome per chr heatmaps}
p1 = syn_PopGenome_results_per_chr %>%
  filter(statistic == "TajimaD") %>%
  ggplot(aes(x = Population, y = as.numeric(chromosome), fill = Estimate)) +
  geom_tile() +
  scale_fill_viridis_c() +
  labs (x = "Populations", y = "Chromosome",
        title = "Tajima's D in synonymous positions",
        subtitle = str_wrap(paste(""), width = 70),
        fill = "Tajima's D")+
  theme_light()

p2 = syn_PopGenome_results_per_chr %>%
  filter(statistic == "Nuc_Div_per_site") %>%
  ggplot(aes(x = Population, y = as.numeric(chromosome), fill = Estimate)) +
  geom_tile() +
  scale_fill_viridis_c(option = "magma") +
  labs (x = "Populations", y = "Chromosome",
        title = str_wrap(paste("Nucleotide diversity per site ",
                               "in synonymous positions"), width = 40),
        subtitle = str_wrap(paste(""), width = 70),
        fill = "Nucleotide diversity")+
  theme_light()
```



```{r PopGenome per gene, message = F, warning = F, results = F}

PopGenome_results_list = list()

### Looping through each chromosome, generate and record all statistics

for (chr in chr_vec) {
  # tryCatch aborts the current loop if the "if" statement throws an error (to avoid processing an empty gff file). An empty gff could occur if the current chromosome lacks any annotated genes/features
    tryCatch({


# skip the loop if the gff file is empty! Empty gff files can happen if a chromosome has no annotated genes.
info <- file.info(paste0(project_dir, "PopGenome_splitchr/gff/", chr,"/", chr,".gff"))[,"size"]
if (info==0) stop(paste("No genes on chr", chr,"- skipping!"))

### define paths and load data
vcf.path <- paste0(Pop_vcf_dir, chr)
gff.path <- paste0(Pop_gff_dir, chr)
GENOME.class <- readData(vcf.path, format="VCF", include.unknown=TRUE, gffpath=gff.path)
all <- unlist(get.individuals(GENOME.class))

# check how many SNPs were loaded using
GENOME.class@n.biallelic.sites



# Important: the output only refers to pop1, pop2, pop3 instead of the listed pops below. You must record the correct order of pop names
GENOME.class <- set.populations(GENOME.class, list(all, V1, V2, V3, V4, V5, V6), diploid = FALSE)
GENOME.class <- set.synnonsyn(GENOME.class, ref.chr=paste0(Pop_ref_dir, chr,".fa"),save.codons=TRUE)
# check assignment of populations using GENOME.class@populations (optional)

### split GENOME.class into genes (further options are: exon, etc.), feature must be mentioned in GFF file!
GENOME.class.split <- splitting.data(GENOME.class, subsites="gene")

### calculate summary stats per gene
GENOME.class.split <- neutrality.stats(GENOME.class.split)
GENOME.class.split <- diversity.stats(GENOME.class.split)

### Build dataframes with summary stats per gene and population
data.Number_SNPs <- data.frame(GENOME.class.split@n.segregating.sites, statistic="Number_SNPs", chromosome = chr, position=GENOME.class.split@region.names)
data.TajD <- data.frame(GENOME.class.split@Tajima.D, statistic="TajimaD", chromosome = chr, position=GENOME.class.split@region.names)
data.Nucl_div <- data.frame(GENOME.class.split@nuc.diversity.within, statistic="Nuc_Div", chromosome = chr, position=GENOME.class.split@region.names)
data.Nucl_div_per_site <- data.frame(GENOME.class.split@nuc.diversity.within/GENOME.class.split@n.sites, statistic="Nuc_Div_per_site", chromosome = chr, position=GENOME.class.split@region.names)

# syn, non-syn counts per gene (value = 0 equals non-synonymous change, value = 1 equals syn. change)
syn.count <- sapply(GENOME.class.split@region.data@synonymous, function(x) {sum(x == 1, na.rm = T)})
nonsyn.count <- sapply(GENOME.class.split@region.data@synonymous, function(x) {sum(x == 0, na.rm = T)})

data.Number_synSNPs <- data.frame(pop.1=syn.count, pop.2="NA", pop.3="NA", pop.4="NA",
                                  pop.5="NA", pop.6="NA", pop.7="NA",
                                  statistic="Number_synSNPs", chromosome = chr,
                                  position=GENOME.class.split@region.names)
data.Number_nonsynSNPs <- data.frame(pop.1=nonsyn.count, pop.2="NA", pop.3="NA", pop.4="NA",
                                  pop.5="NA", pop.6="NA", pop.7="NA",
                                  statistic="Number_nonsynSNPs", chromosome = chr,
                                  position=GENOME.class.split@region.names)

data.full <- rbind(data.Number_SNPs, data.Number_synSNPs, data.Number_nonsynSNPs,
                   data.TajD, data.Nucl_div, data.Nucl_div_per_site)

PopGenome_results_list[[chr]] = data.full
  # used to abort loop
  }, error=function(e){})
}   

PopGenome_results_per_gene = bind_rows(PopGenome_results_list)
rm(PopGenome_results_list)

```

```{r sumstat per gene violin plot }

# Tajima's D
temp = PopGenome_results_per_gene %>%
  dplyr::filter(statistic == "TajimaD") %>%
  na_if(., "NaN") %>%
  dplyr::mutate_at(vars(starts_with("pop")), funs(as.numeric)) %>%
  pivot_longer(-c(statistic, chromosome, position), names_to = "Population", values_to = "Estimate") %>%
  separate(position, into = c("start", "stop"))

temp_sum = temp %>% group_by(Population) %>%
  dplyr::summarize(Median_value = median(Estimate, na.rm = T))

temp = full_join(temp,temp_sum)

p3 = ggplot(temp, aes(x = Population, y = as.numeric(Estimate), fill = Median_value)) +
  geom_violin() +
  geom_boxplot(width = 0.1,
                 outlier.shape = NA, color = "white")+
  labs (x = "", y = "Tajima's D",
        title = "Tajima's D per population in genes",
        subtitle = str_wrap(paste(""), width = 70),
        fill = "Median per pop") +
  theme_light() +
  scale_fill_viridis_c()


# Nucleotide diversity
temp = PopGenome_results_per_gene %>%
  dplyr::filter(statistic == "Nuc_Div_per_site") %>%
  na_if(., "NaN") %>%
  dplyr::mutate_at(vars(starts_with("pop")), funs(as.numeric)) %>%
  pivot_longer(-c(statistic, chromosome, position), names_to = "Population", values_to = "Estimate") %>%
  separate(position, into = c("start", "stop"))  

temp_sum = temp %>% group_by(Population) %>%
  dplyr::summarize(Median_value = median(Estimate, na.rm = T))

temp = full_join(temp,temp_sum)
p4 = ggplot(temp, aes(x = Population, y = log(as.numeric(Estimate)), fill = Median_value)) +
  geom_violin() +
  labs (x = "", y = str_wrap(paste("Nucleotide diversity per site",
                                   "in log scale"), width = 30),
        title = str_wrap(paste("Nucleotide diversity per site ",
                               "per population in genes"), width = 50),
        subtitle = str_wrap(paste(""), width = 70),
        fill = "Median per pop")+
  theme_light() +
  scale_fill_viridis_c(option = "magma")+
  geom_boxplot(width = 0.1,
                 outlier.shape = NA, color = "white")


```

```{r}

plot_grid(p1, p2, p3, p4, labels = c('A', 'B', 'C', 'D'), label_size = 12, ncol = 2)

```



## Site frequency spectrum
```{bash prepare dadi inputs, eval =F}

#Filter vcf file for only synonymous SNPs
vcftools \
  --vcf ${VCFDIR}${VCFNAME_NOMAF}.recode.vcf \
  --positions ${SUMST}Synonymous_SNPs.list.txt \
  --remove-filtered-all \
  --keep $ZTLIST \
  --non-ref-ac-any 1 \
  --max-missing 1.0 --min-alleles 2 --max-alleles 2 \
  --recode \
  --out ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn

#Create one count file per population
for x in {1..6} ;
do
cut -f 1,2 ${POPSTR}${VCFNAME}.pass_noNA.high_anc_coef_snmf.tsv \
  | grep -w "V${x}" | cut -f 1 \
  > ${SUMST}${VCFNAME}.pass_noNA.high_anc_coef_snmf.pop${x}.ind

vcftools \
  --vcf ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn.recode.vcf \
  --keep ${SUMST}${VCFNAME}.pass_noNA.high_anc_coef_snmf.pop${x}.ind \
  --remove-filtered-all \
  --counts \
  --out ${SUMST}${VCFNAME_NOMAF}.pass_noNA.high_anc_coef_snmf.pop${x}

done


#TODO: Filter vcf file for monomorphic SNP in outgroup and use to create dadi output?
/Users/feurtey/Documents/Software/vcftools_jydu/src/cpp/vcftools \
  --vcf ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn.recode.vcf \
  --recode-INFO-all --recode \
	--out ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn.for_dadi \
	--max-indv 1


/Users/feurtey/Documents/Software/bcftools/bcftools query -f '%CHROM\t%POS\t%REF[\t%TGT]\n' \
  ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn.for_dadi.recode.vcf > \
  ${SUMST}${VCFNAME_NOMAF}.pass_noNA.syn.for_dadi.tab

```

```{r plot SFS}
SFS_counts_list = list()

for (x in c(1:6)) {
count_file = paste0(Sumstats_dir, vcf_name_nomaf,
                    ".pass_noNA.high_anc_coef_snmf.pop",
                    x,".frq.count")

counts = read_tsv(count_file,
                  skip = 1, col_names = F) %>%
         separate(X5, into = c("REF allele", "REF_count")) %>%
         separate(X6, into = c("ALT allele", "ALT_count")) %>%
         dplyr::mutate(MAC = pmin(as.numeric(REF_count), as.numeric(ALT_count))) %>%
         dplyr::mutate(Pop = x)
SFS_counts_list[[x]] = counts
}
SFS_counts = bind_rows(SFS_counts_list)

SFS_counts %>%
  filter(MAC > 0) %>%
  dplyr::group_by(Pop, MAC) %>%
  dplyr::count(name = "count") %>%
  ggplot(aes(as.numeric(x = as.numeric(MAC)), y = count)) +
    geom_bar(stat = "identity") +
    labs(title = "Site frequency spectrum from the different populations") +
    theme_bw() +
    facet_wrap(Pop~., scales = "free")

```

<br><br>


# Repeat-induced point mutations and transposable elements
***
Previously, based on the study of TE and RIP in 9 *Z.tritici* genomes, a hypothesis was drawn.
![Repeat Induced Point (RIP) mutations in transposons of Zymoseptoria spp.](/Users/feurtey/Documents/Postdoc_Eva/Manuscripts/Cecile_TE_annot/Lorrain_TE_09032020/Figure_4.png)
**Figure from Lorrain et al. 2020: Repeat Induced Point (RIP) mutations in transposons of Zymoseptoria spp.** Histograms of Composite RIP index (CRI) frequencies of transposons estimated using a 50bp sliding windows approach as follows: CRI =(TpA/ ApT) – (CpA + TpG/ ApC + GpT) for A) Z. passerinii, Z. ardabiliae, Z. brevis and Z. pseudotritici, and B) Iranian Z. tritici isolates and C) European Z. tritici isolates. Vertical dash lines exhibit the threshold (0) above which CRI values indicate a RIP signature.


The lower RIP in TEs of European samples, as compared to Iranian isolates, could indicate a loss of RIP in *Z.tritici* when it spread out of its area of origin. Here, I would like to investigate this possibility in the different pop.


## RIP and TE content between populations
The data plotted here are based on the following steps:

 * Map the reads on TE consensus (from Lorrain et al. 2020, so it includes only Iranian and European samples) and create two bins: reads mapping on TEs and reads that are not mapping.
 * Measuring the RIP composite index for reads that mapped on TE.
 * Estimating the index median in TE reads per isolate.


First, I mapped the reads on the TE consensus created by Ursula based on Thomas's pangenome. I visualize the results here in terms of percentage of reads mapping on these consensus.
```{r TE content estimation plots}

#Reading in the data
TE_qty = read_delim(paste0(RIP_DIR, "Nb_reads.txt"), delim = " ") %>%
  dplyr::filter(Total_reads > Te_aligned_reads) %>%
  dplyr::mutate(Percent_TE_Reads = Te_aligned_reads * 100 / Total_reads) %>%
  left_join(., Zt_meta) %>%
  unite(Continent, Country, ID_file, col = "for_display", remove = F)

world_avg <-
  TE_qty  %>%
  dplyr::summarize(avg = mean(as.numeric(Percent_TE_Reads), na.rm = T)) %>%
  pull(avg)

#Building the basic violin plot per continent
TE_prop =  TE_qty %>%
  filter(!is.na(Continent)) %>%
  ggplot(aes(x = Continent, y = Percent_TE_Reads, fill = Continent)) +
  geom_hline(aes(yintercept = world_avg),
             color = "gray30", size = 0.6, linetype = "dashed") +
    geom_violin(alpha = .8) +
  stat_summary(fun = mean, geom = "point", size = 2, color = "grey30") +
    theme_classic() + Fill_Continent + Color_Continent +
  theme_cowplot()  +
    theme(axis.text.x = element_text(angle = 40, hjust = 1)) +
  labs (x = "", y = str_wrap("Percentage of reads", width = 30),
        title = "Amount of reads mapping on TE consensus per continent",
        subtitle = str_wrap(paste(""), width = 70))

#TE_prop


#One-way ANOVA with blocks
##Define linear model
model = lm(Percent_TE_Reads ~ Continent + Collection ,
          data=TE_qty)
summary(model)   ### Will show overall p-value and r-squared

##Conduct analysis of variance
Anova(model,type = "II")  
summary(model)

hist(residuals(model), col="darkgray")

#Post-hoc analysis:  mean separation tests
library(multcomp)
library(lsmeans)

marginal = lsmeans(model, ~ Continent)

pairs(marginal, adjust="tukey")

CLD = cld(marginal,
          alpha   = 0.05,
          Letters = letters,  ### Use lower-case letters for .group
          adjust  = "tukey")  ### Tukey-adjusted p-values

CLD

CLD$.group=gsub(" ", "", CLD$.group)

### Plot
TE_prop +
  geom_text(data = CLD, aes(x = Continent, label = .group, y = 34), color   = "black")

TE_qty %>%
  filter(!is.na(Continent)) %>%
  filter(Collection != "Hartmann_FstQst_2015") %>%
  ggplot(aes(x = Continent, y = Percent_TE_Reads, fill = Continent)) +
  geom_hline(aes(yintercept = world_avg),
             color = "gray30", size = 0.6, linetype = "dashed") +
    geom_violin(alpha = .8) +
  stat_summary(fun = mean, geom = "point", size = 2, color = "grey30") +
    theme_classic() + Fill_Continent + Color_Continent +
  theme_cowplot()  +
    theme(axis.text.x = element_text(angle = 40, hjust = 1)) +
  labs (x = "", y = str_wrap("Percentage of reads", width = 30),
        title = "Amount of reads mapping on TE consensus per continent",
        subtitle = str_wrap(paste(""), width = 70))

```
The statistics used here are a one-way [ANOVA with block](https://rcompanion.org/handbook/I_06.html). Blocks are used in an analysis of variance or similar models in order to account for suspected variation from factors other than the treatments or main independent variables being investigated. Here I considered the collection as the confounging factor. It definitely has an effect and was thus accounted for in the statistics related to TE content and to RIP level.

I would like to go finer in the TE content analysis and look at the reads aligning on each consensus sequence.
```{r reads per TE}
reads_per_TE = read_delim(paste0(RIP_DIR, "Nb_reads_per_TE.txt"), delim = "\t",
                    col_names = c("ID_file", "TE", "Length",
                                  "# mapped read-segments",  "# unmapped read-segments")) %>%
  separate(TE, into = c("Superfamily", "TE_id"), sep = "_", remove = F) %>%
  dplyr::mutate(Order = ifelse(!grepl('^D',TE), "Class II (DNA transposons)", "Class I (retrotransposons)")) %>%
  left_join(readxl::read_excel(paste0(metadata_dir, "Zt_global_data_set_09April2020_DC_AFperso.xlsx"),
                           sheet = 1, n_max = 1000)) %>%
  unite(Continent, Country, ID_file, col = "for_display", remove = F)

temp = reads_per_TE %>% group_by(ID_file) %>%
       dplyr::summarise(Reads_mapped_per_TE = sum(`# mapped read-segments`))

reads_per_TE = left_join(reads_per_TE, temp) %>%
  dplyr::mutate(Normalized_nb_reads_mapped = `# mapped read-segments` / Reads_mapped_per_TE)



#reads_per_TE %>%
#  mutate(ID_file = fct_reorder(ID_file, Continent)) %>%
#  ggplot(aes(x = ID_file, y = Normalized_nb_reads_mapped, fill = Superfamily)) +
#    geom_bar(stat = "identity")
```



Let's try to make a PCA based on the proportion of reads mapping on each TE. Is there a geographical clustering in the TE content?
```{r PCA prop reads TE}
TE_PCA_mat = reads_per_TE %>%
  dplyr::select(ID_file, Continent, for_display, TE, Normalized_nb_reads_mapped) %>%
  spread(key = TE, value = as.numeric(Normalized_nb_reads_mapped))

temp =as.matrix(sapply(TE_PCA_mat[,c(5:ncol(TE_PCA_mat))], as.numeric))
temp = temp[,apply(temp, 2, var, na.rm=TRUE) != 0]

TE.pca = prcomp(temp, center = TRUE,scale. = TRUE)
#summary(TE.pca)

#library(ggfortify)
#autoplot(TE.pca, data = TE_PCA_mat, colour = 'Continent', shape = T, label.size = 3)

p1 = cbind(TE_PCA_mat, as.data.frame(TE.pca$x)) %>%
  ggplot(aes(x = PC1, y = PC2, col = Continent, text = for_display)) +
  geom_point(alpha = 0.6) + theme_bw() + Color_Continent +
  labs(title = "PCA based on normalized reads mapping on each TE consensus")
ggplotly(p1)

p2 = cbind(TE_PCA_mat, as.data.frame(TE.pca$x)) %>%
  ggplot(aes(x = PC2, y = PC3, col = Continent, text = for_display)) +
  geom_point(alpha = 0.6) + theme_bw() + Color_Continent
ggplotly(p2)

p3 = cbind(TE_PCA_mat, as.data.frame(TE.pca$x)) %>%
  ggplot(aes(x = PC3, y = PC4, col = Continent, text = for_display)) +
  geom_point(alpha = 0.6) + theme_bw() + Color_Continent
ggplotly(p3)
```

Let's now plot the same results but all 4 axis against all and not interactive.
``` {r PCA prop TE ggpairs}
#And now all against all but not interactive
temp = as.tibble(cbind(TE_PCA_mat, as.data.frame(TE.pca$x))) %>%
  dplyr::select(for_display, Continent, PC1, PC2, PC3, PC4)

p = ggpairs(temp, columns = c(3:6), ggplot2::aes(col=Continent, fill = Continent, alpha = 0.6),
            title = "PCA based on normalized reads mapping on each TE consensus",
            upper = list(continuous = "points", combo = "box_no_facet"))

for(i in 1:p$nrow) {
  for(j in 1:p$ncol){
    p[i,j] <- p[i,j] + theme_bw() + Color_Continent +Fill_Continent
  }
}

p
```

It does look like there is clustering of samples according to geography. This is interesting as it shows that the types of TEs are different in different populations.
<br>


I now look at the repeat-induced point mutations in reads that map on the different TE consensus. We expect to see differences in the different geographical groups so I start by visualizing this.
```{r RIP input and plot per geography}

RIP=read_tsv(paste0(RIP_DIR, "Composite_index.txt"),
             col_names = c("ID_file", "TE",  "Composite_median", "Composite_mean" )) %>%
  separate(TE, into = c("Superfamily", "TE_id"), sep = "_", remove = F) %>%
  mutate(Order = ifelse(!grepl('^D',TE), "Class II (DNA transposons)", "Class I (retrotransposons)"))%>%
  left_join(readxl::read_excel(paste0(metadata_dir, "Zt_global_data_set_09April2020_DC_AFperso.xlsx"),
                           sheet = 1, n_max = 1000)) %>%
  unite(Continent, Country, ID_file, col = "for_display", remove = F) %>%
  left_join(., reads_per_TE)
#DONE: merge with reads_per_TE to be able to filter the points that have too few reads mapped!

#Per continent

world_RIP_avg <-
  RIP %>%
  filter(TE == "RIP_est") %>%
  dplyr::summarize(avg = mean(as.numeric(Composite_median), na.rm = T)) %>%
  pull(avg)

temp = RIP %>%
  filter(TE == "RIP_est") %>%
  filter(!is.na(Continent)) %>%
  group_by(Continent) %>%
  dplyr::mutate(region_avg = mean(as.numeric(Composite_median), na.rm = T))

RIP_plot = ggplot(temp, aes(x = Continent,
                            y = as.numeric(Composite_median),
                            color = Continent))   +
  coord_flip() +
  geom_segment(aes(x = Continent, xend = Continent,
        y = world_RIP_avg, yend = region_avg), size = 0.8) +
  geom_jitter(size = 1.5, alpha = 0.2, width = 0.2) +
  geom_hline(aes(yintercept = world_RIP_avg), color = "gray70", size = 0.6) +
  stat_summary(fun = mean, geom = "point", size = 5) +
  Color_Continent +
  theme_cowplot() +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 40, hjust = 1)) +
  labs (x = "", y = "RIP composite index",
        title = "RIP levels per continents",
        subtitle = str_wrap(paste("The RIP levels in reads mapping on TE consensus",
                                  "are high in the Middle-East",
                                  "and low in North America in particular."), width = 70))


#Statistical test
#One-way ANOVA with blocks
##Define linear model
model = lm(as.numeric(Composite_median) ~ Continent + Collection ,
          data=temp)
summary(model)   ### Will show overall p-value and r-squared

##Conduct analysis of variance
Anova(model,type = "II")  
summary(model)

hist(residuals(model), col="darkgray")

#Post-hoc analysis:  mean separation tests
marginal = lsmeans(model, ~ Continent)

pairs(marginal, adjust="tukey")

CLD_RIP = cld(marginal,
          alpha   = 0.05,
          Letters = letters,  ### Use lower-case letters for .group
          adjust  = "tukey")  ### Tukey-adjusted p-values

CLD_RIP

CLD_RIP$.group=gsub(" ", "", CLD_RIP$.group)

text_y = (max(as.numeric(temp$Composite_median), na.rm = T) + 0.1*max(as.numeric(temp$Composite_median), na.rm = T))

RIP_plot +
  geom_text(data = CLD_RIP, aes(x = Continent,
                            y = text_y,
                            label = .group), color = "black")
```


It is known that different TE groups, in particular the MITEs, which are particularly small are less RIPped than other types of TEs. I wanted to check whether we saw such a pattern and so I visualize here the RIP per superfamily of TEs and then as related to the size of the consensus.
```{r RIP plot per TE group}
#Per  TE superfamily
RIP  %>%
  filter(Normalized_nb_reads_mapped > 0.0001) %>%
  group_by(Superfamily)%>%
  mutate(median_Superfamily=median(Composite_median, na.rm = T) )%>%
  ggplot(aes(x = Superfamily,
             y = as.numeric(Composite_median),
             fill = median_Superfamily)) +
    geom_boxplot(outlier.shape = NA) +
    theme_bw() +
    ylab("Median of composite index on TE reads") +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 40, hjust = 1)) +
  ylim(-1, 5) + geom_hline( yintercept = 0, color = "navy")

temp = RIP  %>%
  filter(Normalized_nb_reads_mapped > 0.0001) %>%
  group_by(Superfamily, Continent, Order)%>%
  dplyr::summarize(median_Superfamily=median(Composite_median, na.rm = T) )

temp %>%
  filter(Order == "Class I (retrotransposons)") %>%
  ggplot(aes(x = Superfamily,
             y = median_Superfamily,
             fill = Continent)) +
    geom_bar(stat = "identity", position=position_dodge()) +
  Fill_Continent +    
  theme_bw() +
    ylab("Median of composite index on TE reads") +
    theme(axis.text.x = element_text(angle = 40, hjust = 1))

temp %>%
  filter(Order == "Class II (DNA transposons)") %>%
  ggplot(aes(x = Superfamily,
             y = median_Superfamily,
             fill = Continent)) +
    geom_bar(stat = "identity", position=position_dodge()) +
  Fill_Continent +    
  theme_bw() +
    ylab("Median of composite index on TE reads") +
    theme(axis.text.x = element_text(angle = 40, hjust = 1))

#As relating to TE size
#NB: in the following plot, the alpha parameter is set to make the TE without any reads (or near so) invisible
#This means that not all consensus are visible. In particular, some, annotated  by Ursula as "verylowcopy" are not.
TE_consensus_faidx =read_tsv(paste0(TE_RIP_dir, "Badet_BMC_Biology_2020_TE_consensus_sequences.fasta.fai"),
             col_names = c("TE",  "length",  "offset",  
             "number of bases per line",  "number of bytes per line"))

p = inner_join(RIP, TE_consensus_faidx) %>%
  dplyr::group_by(Order, TE, length) %>%
  filter (TE != "RIP_est") %>%
  filter(!is.na(Normalized_nb_reads_mapped)) %>%
  dplyr::summarize(median_per_consensus=median(Composite_median, na.rm = T),
                   read_mapped = median(Normalized_nb_reads_mapped), na.rm = T) %>%
  ggplot(aes(x = log(length),
             y = median_per_consensus,
             color = Order)) +
  geom_point(aes( text = TE,
             alpha = log(read_mapped)))  + theme_bw() +
  ylim(c(-2, 4)) + geom_hline(yintercept = 0) +
  labs(x = "TE length (log-scale)",
       y = "Median of RIP composite index",
       title = str_wrap(paste("Median of the RIP composite index for each TE consensus",
                        "against the length of the consensus sequence"), width = 60)) # + geom_smooth(span = 1.5, fill = NA, size =0.7)

ggplotly(p)


p = inner_join(RIP, TE_consensus_faidx) %>%
  filter (TE != "RIP_est") %>%
  dplyr::group_by(Order, TE, length) %>%
  dplyr::summarize(median_per_consensus=median(Composite_median, na.rm = T),
                   read_mapped = median(Normalized_nb_reads_mapped), na.rm = T) %>%
  filter(str_detect(TE, pattern = "SINE") | str_detect(TE, pattern = "MITE") ) %>%
  ggplot(aes(x = log(length),
             y = median_per_consensus,
             color = Order, text = TE,
             alpha = log2(read_mapped))) +
  geom_point()  + theme_bw() +
  ylim(c(-2, 4)) + geom_hline(yintercept = 0)

ggplotly(p)
```

Finally, I look at the relation between the amount of reads mapping on TE consensus and the level of RIP detected. I also investigate several possible bias.  
```{r RIP and TE together}
TE_RIP = inner_join(TE_qty, RIP %>%
  filter(TE == "RIP_est") )

TE_RIP$Sampling_Date[is.na(TE_RIP$Sampling_Date)] <- "Unknown"

temp = TE_RIP %>%
  group_by(Continent) %>%
  dplyr::summarize(TE_qty = mean(Percent_TE_Reads, na.rm = T),
                  Composite_median = mean(as.numeric(Composite_median), na.rm = T)) %>%
  dplyr::mutate(for_display = Continent)

#TE and RIP together
t = ggplot(TE_RIP, aes(as.numeric(Percent_TE_Reads),
                          as.numeric(Composite_median),
                          color = Continent,
                          text = for_display))+
  theme_cowplot()  +
  geom_point(alpha = 0.6) + Color_Continent +
  labs(color = "Geographical group",
       x = "Percentage of TE reads", y = "RIP composite median",
       title = "Amount of transposable elements vs RIP level") +
  geom_point(data = temp, aes(as.numeric(TE_qty),
                                as.numeric(Composite_median),
                                color = Continent), size = 5)
ggplotly(t)


t

bias1 = TE_RIP %>% ggplot(aes(Percent_TE_Reads, as.numeric(Composite_median), color =Collection, text = for_display)) +
  theme_cowplot() +
  geom_point(alpha = 0.8)

#bias2 = TE_RIP %>% ggplot(aes(Percent_TE_Reads, as.numeric(Composite_median), color =Library_strategy, text = for_display)) +
#  theme_cowplot() +
#  geom_point(alpha = 0.8)

ggplotly(bias1)

cowplot::plot_grid(RIP_plot +
                     labs (title = "", subtitle = "") +
                     geom_text(data = CLD_RIP, aes(x = Continent,
                                               y = text_y,
                                               label = .group),
                               color = "black"),
                   TE_prop +
                     labs (title = "", subtitle = "") +
                     geom_text(data = CLD, aes(x = Continent,
                                               label = .group,
                                               y = 34),
                               color   = "black") +
                     theme(legend.position = "none") +
                     coord_flip())

```

```{r}
subset = TE_RIP %>%
  filter(Collection != "Hartmann")

temp = subset %>%
  group_by(Continent) %>%
  dplyr::summarize(TE_qty = mean(Percent_TE_Reads, na.rm = T),
                  Composite_median = mean(as.numeric(Composite_median), na.rm = T)) %>%
  dplyr::mutate(for_display = Continent)

t = ggplot(subset, aes(as.numeric(Percent_TE_Reads),
             as.numeric(Composite_median),
             color = Continent,
             text = for_display)) +
  theme_cowplot()  +
  geom_point(alpha = 0.6) + Color_Continent +
  labs(color = "Geographical group",
       x = "Percentage of TE reads", y = "RIP composite median",
       title = "Amount of transposable elements vs RIP level") +
  geom_point(data = temp, aes(as.numeric(TE_qty),
                                as.numeric(Composite_median),
                                color = Continent), size = 5)
ggplotly(t)
```


Besides geographical origin and collection, I also wanted to check time for subsets of the genomes. The Oceanian samples have often shown their own pattern, so I looked at them separately. Additionally, I am curious about the North American samples since Ursula saw a temporal pattern.
```{r RIP and TE together per region}
#Checking the Oceanian samples
TE_RIP %>%
  filter(Continent == "Oceania") %>%
  ggplot(aes(Percent_TE_Reads, as.numeric(Composite_median), color = as.character(Sampling_Date), shape = Country, text = for_display)) +
  geom_point(alpha = 0.8) +
  theme_cowplot() +
      scale_color_manual(values = blues) +
  labs(color = "Group",
       x = "Percentage of TE reads", y = "RIP composite median",
       title = "TE vs RIP level in Oceania",
       subtitle = str_wrap(paste0("Oceanian samples have shown a clear ",
                                  "temporal and geographical substructure ",
                                  "based on SNPs. How about RIP/TE content?"),
                                  width = 70))

t = TE_RIP %>%
    filter(Country == "United States") %>%
    ggplot(aes(Percent_TE_Reads, as.numeric(Composite_median),
               color = Collection, shape = as.character(Sampling_Date))) +
    geom_point(alpha = 0.8) +
    theme_bw() +
  labs(color = "Geographical group",
       x = "Percentage of TE reads", y = "RIP composite median",
       title = "TE vs RIP level in North America",
       subtitle = str_wrap(paste0("Ursula's data shows a geographical and a ",
                                  "temporal pattern in the TE content. ",
                                  "Can this be recovered here?"),
                                  width = 70))
t
```


The RIP index does seem consistent so far with what Cécile has found, with higher RIP in the Middle-East and African populations and lower in the rest (in particular North America and Oceania).

Careful, there is a strong difference between the data from the Hartmann dataset and the rest. Let's investigate a potential GC bias in the sequencing.


```{r long coverage transform, eval = F}
#The coverage files here are produced by bedtools coverage with the hist option using the aligned bam files and a bed file describing 1kb windows.
# Example loop:
#for sample in STnnJGI_SRR4235066 STnnJGI_SRR4235068 STnnJGI_SRR4235067 STnnJGI_SRR4235068 ; do rsync -avP /legserv/NGS_data/Zymoseptoria/Aligned_reads_Nuc_Mito_genomes/SRA_2019/PE/Bam/${sample}.bam ./ ; ~/Software/bedtools coverage -a Zymoseptoria_tritici.MG2.dna.toplevel.mt+.fa.1kb.bed -b ${sample}.bam -hist > ${sample}.coverage.txt ; done
#And gathered like this:
  #for file in *.coverage.txt ; do sample=$(echo $file | sed 's/.coverage.txt//') ; echo $sample ; awk -v #var=$sample '{print var, $1, $2, $3, $4, $5, $6, $7}' $file ; done > Coverage_in_windows.txt


depth = read_tsv(paste0(TE_RIP_dir, "Coverage_in_windows.txt"),
                             col_names = c("Sample", "Chr", "Start", "Stop",
                                           "Depth", "Nb_bases_with_depth",
                                           "Size", "Fraction_covered")) %>%
    mutate(Sum_bases = Depth * Nb_bases_with_depth) %>%
    group_by(Sample, Chr, Start, Stop) %>%
    summarize(Nb_bases = sum(Nb_bases_with_depth), Sum_depth = sum(Sum_bases)) %>%
    mutate(mean_depth = Sum_depth / Nb_bases)
write_tsv(depth, path = paste0(TE_RIP_dir, "Coverage_in_windows_summary.txt"))

```

```{r Depth per locus on pangenome}
suffix = ".depth_per_window.txt"
files <- list.files(paste0(VAR_dir,"1_Depth_per_window/"), pattern = paste0(suffix, "$"))
smaller_files = sample(files, size = 0, replace =F)
smaller_files = sample(files[grepl("ORE", files)], size = 10, replace =F)
smaller_files[length(smaller_files) + 1] = paste0("ST90ORE_a12_3B_6.chr_1.corrected", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Ukraine_1995_ST95UR_F1c_2", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Chile_1995_STCH95_1G3a_06", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Indiana_1993_I24a_1", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Indiana_1993_I25a_1", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Indiana_1993_I33a_1", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Israel_1992_ISYB1b", suffix)
smaller_files[length(smaller_files) + 1] = paste0("Israel_1992_ISZH2a", suffix)

depth_per_locus = data.frame()

for (i in smaller_files) {
  file_name=paste0(VAR_dir,"1_Depth_per_window/", i)
  sample_name = dplyr::last(str_split(file_name, "/")[[1]]) %>%
  str_replace(., pattern = suffix, replacement = "")
  temp = read_tsv(file_name, col_names = c("Locus_name", "Depth")) %>%
    mutate(ID_file = sample_name)
  depth_per_locus = bind_rows(depth_per_locus, temp)
}


median_depth_cor_per_ind = depth_per_locus %>%
  filter(!grepl("\\[", Locus_name)) %>%
  separate(col = Locus_name, into = c("ignore", "chr", "start", "end")) %>%
  filter(as.numeric(chr) <= 13) %>%
  group_by(ID_file) %>%
  dplyr::summarise(Median_core_depth = median(as.numeric(Depth), na.rm = T))


depth_per_locus = left_join(depth_per_locus, median_depth_cor_per_ind) %>%
  left_join(., readxl::read_excel(paste0(metadata_dir, "Zt_global_data_set_09April2020_DC_AFperso.xlsx"),
                           sheet = 1, n_max = 1000)) %>%
  mutate(Normalized_depth = Depth / Median_core_depth) %>%
  filter(Median_core_depth > 10)


```

```{r estimate GCbias alpha}

#depth = read_tsv(paste0(TE_RIP_dir, "Coverage_in_windows_summary.txt"))
#depth per locus coming from the PAV from pangenome

#t = read_tsv(paste0(TE_RIP_dir, "Zymoseptoria_tritici.MG2.dna.toplevel.mt+.nucl_content")) %>%
#  unite("#1_usercol", "2_usercol", "3_usercol", col = "Locus_name", remove = F) %>%
#  ggplot(aes(`5_pct_gc`)) + geom_density()

Nucl_content = read_tsv(paste0(data_dir, "all_19_pangenome.windows.nuc_GC.tab")) %>%
  unite("#1_usercol", "2_usercol", "3_usercol", col = "Locus_name", remove = F)

scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}


GC_coverage = inner_join(depth_per_locus, Nucl_content,
           by = "Locus_name") %>%
  filter(!grepl("\\[", Locus_name)) %>%
  separate(col = Locus_name, into = c("ignore", "chr", "start", "end")) %>%
  filter(as.numeric(chr) <= 4) %>% #Check GC bias only on core chromosomes to limit accessory bias in coverage
  mutate(scaled_depth = scale_this(Depth))


getAlpha<-function(i){
  #print(i)
  temp = GC_coverage %>%
    filter(ID_file == i) %>%
    mutate(log_depth = log(Depth + 1))

  linearMod <- lm(log_depth ~ `5_pct_gc`, data=temp)  # build linear regression model on full data
  alpha = linearMod$coefficients["`5_pct_gc`"]
  return (alpha)}
v_getAlpha <- Vectorize(getAlpha)

GC_bias = GC_coverage %>%
  dplyr::group_by(ID_file) %>%
  dplyr::summarise(Median_core_depth = mean(Median_core_depth, na.rm = T),
                   Median_depth = mean(Depth, na.rm = T))  %>%
  dplyr::mutate(GC_bias_slope = v_getAlpha(ID_file))

```

```{r, fig.height = 5}

temp = GC_coverage %>%
  filter(chr == 1) %>%
  mutate(GC_percent = round(`5_pct_gc` * 100, 0)) %>%
  mutate(Sampling_Date = ifelse(is.na(Sampling_Date), "corrected", Sampling_Date)) %>%
 group_by(ID_file, GC_percent, Sampling_Date) %>%
 dplyr::summarize(Average_depth = mean(Depth, na.rm = T),
                  Window_count = n())

p1 = temp %>%
 ggplot(aes(x = GC_percent, y = Average_depth, color = ID_file, linetype = Sampling_Date)) +
  geom_line() + theme_bw() + geom_hline(yintercept = 3) +
  theme(legend.position = "top") +
  xlim(c(20, 70)) +
  labs(x = "GC percent of the window",
       y = str_wrap("Average depth per window of a given GC percent", width = 20))

p2 = temp %>%
  dplyr::filter(ID_file == unique(temp$ID_file[[1]])) %>%
  ggplot(aes(GC_percent, Window_count)) + geom_bar(stat = "identity") +
  theme_bw() +
  labs(x = "GC percent of the window",
       y = str_wrap("Number of windows of a given GC percent", width = 20))


p3 = read_tsv(paste0(RIP_DIR, "GC_percent.txt"), col_names = c("ID_file", "TE", "GC_median", "GC_mean")) %>%
  inner_join(readxl::read_excel(paste0(metadata_dir, "Zt_global_data_set_09April2020_DC_AFperso.xlsx"),
                           sheet = 1, n_max = 1000)) %>%
  filter(Continent == "North America") %>%
  ggplot(aes(GC_median, fill = Collection, color = Collection)) +
  geom_density(alpha = 0.4) +
  theme_bw() +
  labs(x = "Median GC content of the reads aligning on TEs") +
  xlim(c(20, 70)) +
  theme(legend.position = "bottom")

plot_grid(p1, p2, p3, nrow = 3, ncol = 1, rel_heights = c(1, 0.5, 0.7))

```
I’ve created a new representation of the GC bias and the first test for the correction.

For the top plot, I have sorted the windows of chromosome 1 in GC percent bins (1% bins). For each bin and for each sample, I then measure the average depth for all windows of the corresponding GC percent and this is what is plotted here.
In the middle, you can see an histogram of the number of windows for each bin and, at the bottom, is the median GC content of reads aligning on TEs which I use as a proxy to estimate the GC content of TEs in general.

As we have seen before, there is a severe GC bias in the older genomes: in the windows with a GC content similar to TE reads (42 - 47), the coverage is often below 3 (black horizontal line). I know that you had tested the effect of depth on your method, Ursula, but this is quite an extreme difference between around 20 to 3... Perhaps this could be tested with a manually GC-biased sample.

I have tried the correction on one sample. You can see it in the top panel as a dashed purple line. It really does correct! Obviously the most extreme values don't get corrected because 0 reads is 0 reads... But it's not as bad as I expected honestly!

I did also try the in silico sequencing with GC bias but I could find only one software which claimed to include GCbias in simulated reads and it really did not go as extreme as we needed, unfortunately.


```{r plot GCbias alpha}
# Selection a smaller number of samples to illustrate the GC bias
temp = sample(GC_coverage %>% pull(ID_file) %>% unique(), size = 9, replace =F)
GC_coverage %>%
  filter(ID_file %in% temp) %>%
  ggplot(aes(`5_pct_gc`, scaled_depth)) +
    geom_hex(bins = 70) +
    scale_fill_continuous(type = "viridis") +
    theme_bw() + facet_wrap(~ID_file, scale = "free") +
    geom_smooth(method = "lm", se = FALSE,
                color = "#29AF7F", size= 0.7) +
    labs(x = "GC percent per window",
         y = "Depth per window",
         title = "Illustration of the GC bias",
         subtitle = "I use the slope of a linear model to infer the GC bias.")

#The following block is silenced.
#It was meant to check whether I am indeed getting the same results with the model and the plot.
silence = 'i=temp[1]
temp = GC_coverage %>%
     filter(ID_file == i) %>%
     mutate(log_depth = scaled_depth)
linearMod <- lm(log_depth ~ `5_pct_gc`, data=temp)  # build linear regression model on full data
p = GC_coverage %>%
  filter(ID_file == i) %>%
ggplot(aes(`5_pct_gc`, scaled_depth)) +
  geom_hex(bins = 70) +
  scale_fill_continuous(type = "viridis") +
  theme_bw() + facet_wrap(~ID_file, scale = "free") +
  geom_smooth(method = "lm", se = FALSE, color = "#29AF7F")
p + geom_abline(intercept = linearMod$coefficients["(Intercept)"], slope = linearMod$coefficients["`5_pct_gc`"]) +
  ylim(c(-6, 15))'


# Checking on a possible link between depth and GC bias
p1 = median_depth_cor_per_ind %>%
  ggplot(aes(Median_core_depth)) +
  geom_density(fill = mycolorsCorrel[7], col = mycolorsCorrel[1]) +
  theme_bw() +
  labs(x = "Median depth on core chromosmome")
p2 = ggplot(GC_bias, aes(GC_bias_slope)) + geom_density()+
  geom_density(fill = myColors[1], col = myColors[1], alpha = 0.8) +
  theme_bw()+
  labs(x = "GC bias")

top = cowplot::plot_grid(p1, p2, labels = c("A", "B"))

p3 = inner_join(GC_bias, TE_RIP, by = "ID_file") %>%
  ggplot(aes( Median_core_depth, GC_bias_slope, text = for_display, color = Collection)) +
  geom_point() + theme_light() +
  labs(x = "Median depth on core chromosmome",
       y = "GC bias")

cowplot::plot_grid(top, p3, ncol = 1, nrow = 2, labels = c("", "C"))


# And now let's investigate if there is a correlation between GC bias and the values of interest from before
temp = inner_join(GC_bias, TE_RIP, by = "ID_file") %>%
  pivot_longer(cols = c(Composite_median, Percent_TE_Reads), names_to = "Confounded estimate", values_to = "Estimated value") %>%
  ggplot(aes(`Estimated value`, GC_bias_slope, text = for_display, color = Collection)) +
  geom_point() + theme_light() +
  facet_wrap(vars(`Confounded estimate`), scales = "free") +
  labs(x = "",
       y = "GC bias (slope of the per window estimate)",
       title = "Effect of GC bias on TE and RIP estimation")
ggplotly(temp)

t = TE_RIP %>%
     ggplot(aes(Percent_TE_Reads, as.numeric(Composite_median), color = Collection,
                shape = as.character(Sampling_Date), text = for_display)) +
     geom_point(alpha = 0.8) +
     theme_bw()
ggplotly(t)

```


I tried to correct the GC bias by using deeptools correctGCBias on one sample from the Oregon population. I then rerun the PCA for the TE content. Although the individual values for the depth did change, it did not change the place of the sample in the PCA.

I don't know if the GC bias is the reason for the clear difference between the Hartmann dataset or if the two are consequence of something else. Either way, it does not seem reasonable to compare this dataset to the rest. It seems that, inside of this dataset, the observed differences match with what can be inferred from the rest of the samples.
<br>



## RIP along the chromosomes

```{r, fig.height = 5}
RIP_in_high_copies_TE = read_tsv(paste0(TE_RIP_dir, "All_genomes.all_TEs.GC.RIP.tab"),
             col_names = c("Sample", "Seq_ID", "GC", "Product_index", "Substrate_index", "Composite_index"))

temp = RIP_in_high_copies_TE %>%
  separate(Seq_ID, into = c("Sample", "Chrom", "Start", "End"),
           sep = "\\.|-|:", remove = F) %>%
  dplyr::mutate(Start = as.integer(Start), End = as.integer(End)) %>%
  dplyr::mutate(Coord = (Start + End)/2)

#temp %>%
#  filter(Chrom == "chr_4") %>%
#  filter(Composite_index <= 2 & Composite_index >= - 2 )%>%
#  ggplot(aes(Coord, Composite_index, col = Composite_index)) +
#    geom_point() +
#    facet_wrap (vars(Sample), ncol = 1) +
#  theme_bw() +
#  scale_color_viridis_c()

temp %>%
  dplyr::mutate(Nb = str_pad(round((Coord / 100000), 0), 6, pad = "0")) %>%
  filter(Composite_index >= -2 & Composite_index<= 2) %>%
  #filter(Chrom == "chr_1") %>%
  unite(Window, Chrom, Nb) %>%
  group_by(Sample, Window) %>%
  dplyr::summarize(Composite = mean(Composite_index, na.rm = T)) %>%
  ggplot(aes(Window, Sample, fill = Composite)) +
    geom_tile() +
  theme_bw() +
  scale_fill_viridis_c()

temp %>%
  filter(Composite_index >= -3 & Composite_index<= 3) %>%
  mutate(Chr = as.integer(str_replace(Chrom, "chr_", ""))) %>%
  group_by(Sample, Chr) %>%
  dplyr::summarize(Composite = mean(Composite_index, na.rm = T)) %>%
  ggplot(aes(Chr, Sample, fill = Composite)) +
    geom_tile() +
  theme_bw() +
  scale_fill_viridis_c()
```


## Is dim2 present in its intact version in some populations?

Next step will be to check if dim2 is present where the RIP values suggest they are: intact copies in the Middle-East and Africa and absence/degeneration in the rest.
Here, I use **de novo** genome assemblies and try to identify copies of dim2. For this, I use a deRIPped sequence of dim2 in the reference, blasted it on to Zt10 to get the sequence of Zt10_dim2 since it is known to have an intact sequence (see Mareike's paper). I then compare this sequence (blastn) with de **de novo** assemblies to pull all the copies and identify the highest identity score.
```{bash dim2_detect_blast, eval = F}
#Here the Zt10_dim2_from_MgDNMT_deRIP.fa is the sequence of Zt10_6.417 which corresponds to the deRIPPed version of dim2 in the reference IPO323 https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2940312/pdf/GEN186167.pdf


#sbatch -p normal.168h --array=1-1195%50 Detect_gene_blast_array.sh /home/alice/WW_PopGen/Directories_new.sh /data2/alice/WW_project/0_Data/Zt10_dim2_from_MgDNMT_deRIP.fa /home/alice/WW_PopGen/Keep_lists_samples/Good_assemblies.args Illumina /data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/1_Blast_dim2_deRIPped/


```

Let's look at the results as dot plots and compare the results from the dim2 blast to the RIP composite index. So far the Middle-Eastern samples seem quite similar to one another, whereas other regions contain way more variability such as Europe.

In order to identify the native dim2 copy in genomes, I look for several things:

 * the blast match has to be on the same contig as at least one of the two known flanking genes
 * the blast match has to be between the two flanking genes if both are on the same contig or less than 10 kb from the known flanking gene on the same contig
```{r dim2 blast results dots}
  
  
system(paste0("cat ", DIM2_DIR, "Results_blast_dim2*txt > ", DIM2_DIR, "Overall_results_blast_dim2.txt"))

length_dim2 = 3846
length_flank1 = 3689
length_flank2 = 1222
threshold_length_dim2 = 0.8 * length_dim2
threshold_length_flank1 = 0.8 * length_flank1
threshold_length_flank2 = 0.8 * length_flank2

dim2_blast_results_complete = read_delim(paste0(DIM2_DIR, "Overall_results_blast_dim2.txt"), delim = " ",
                                col_names = c("sample", "gene", "qseqid", "sseqid", "pident", "length",
                                              "mismatch", "gapopen", "qstart", "qend",
                                              "sstart", "send", "evalue", "bitscore"))

flank1 = dim2_blast_results_complete %>%
  filter(gene == "dim2_flank1") %>%
  dplyr::select(sample, gene, sseqid, length, sstart, send) %>%
  dplyr::mutate(midcoord_flank1 = (sstart + send)/2) %>%
  filter(length > threshold_length_flank1) %>%
  pivot_wider(names_from = gene, values_from = sseqid) %>%
  dplyr::select(-length, -sstart, -send) %>%
  group_by(sample) %>%
  dplyr::mutate(nb_gene = n())

flank2 = dim2_blast_results_complete %>%
  filter(gene == "dim2_flank2") %>%
  dplyr::select(sample, gene, sseqid, length, sstart, send) %>%
  dplyr::mutate(midcoord_flank2 = (sstart + send)/2) %>%
  filter(length > threshold_length_flank2) %>%
  pivot_wider(names_from = gene, values_from = sseqid) %>%
  dplyr::select(-length, -sstart, -send) %>%
  group_by(sample) %>%
  dplyr::mutate(nb_gene = n())

#First let's extract some information such as finding the middle coordinates for the
# 3 genes of interest
dim2_blast_results = dim2_blast_results_complete %>%
  dplyr::filter(gene == "dim2") %>%
  full_join(., flank1, by = "sample") %>%
  full_join(., flank2, by = "sample") %>%
  dplyr::mutate(dim2_flank1 = replace_na(dim2_flank1, "Not_found"),
                dim2_flank2 = replace_na(dim2_flank2, "Not_found"),
                midcoord_flank1 = replace_na(midcoord_flank1, "0"),
                midcoord_flank2 = replace_na(midcoord_flank2, "0")) %>%
  dplyr::mutate(midcoord_flank1 = as.numeric(midcoord_flank1),
                midcoord_flank2 = as.numeric(midcoord_flank2))  %>%
  dplyr::mutate(ave_coord = (sstart + send)/2)  %>%
  dplyr::mutate(min_fl = ifelse(midcoord_flank1 > midcoord_flank2,
                                midcoord_flank2, midcoord_flank1))  %>%
  dplyr::mutate(max_fl = ifelse(midcoord_flank1 > midcoord_flank2,
                                midcoord_flank1, midcoord_flank2))

#Now, let's compare the blast results of dim2 with the flanking genes
# (contig name and distance)
dim2_blast_results = dim2_blast_results %>%
  dplyr::mutate(is_same_contig = ifelse(sseqid == dim2_flank1 & sseqid == dim2_flank2,
                                 "Both",
                                 ifelse(sseqid != dim2_flank1 & sseqid != dim2_flank2,
                                 "None",
                                 ifelse(sseqid == dim2_flank1, "Flank1",
                                 ifelse(sseqid == dim2_flank2, "Flank2", "What"))))) %>%
  dplyr::mutate(distance = ifelse(is_same_contig == "None", "No_distance",
                           ifelse(is_same_contig == "Both",
                                  ifelse(ave_coord >= min_fl &
                                         ave_coord <= max_fl ,
                                  "Distance_OK", "Not_between"),
                                  ifelse(is_same_contig == "Flank1",
                                         ifelse((abs(midcoord_flank1 - ave_coord) <= 10000),
                                  "Distance_OK", "Too_far"),
                                  ifelse((abs(midcoord_flank2 - ave_coord) <= 10000),
                                  "Distance_OK", "Too_far"))))) %>%
  mutate(Nb_flanking_found_2cat = ifelse(is_same_contig == "None", "0",
                                         ifelse(distance == "Distance_OK", ">1", "0")))



  #dplyr::select(sample, sseqid, length, dim2_flank1, dim2_flank2, is_same_contig) %>%



dim2_blast_results %>%
  ggplot(aes(length)) +
    geom_density(alpha = 0.7) +
    theme_bw() +
    geom_vline(aes(xintercept = threshold_length_dim2), color = "gray70", size = 0.6) +
    labs(x = "Length (bp)",
         y = "Density",
         title = "Length of all blast matches against Zt10dim2",
         subtitle = str_wrap(paste("There is a large range in the size of the matches.",
                                   " In order to ignore very short matches, I could set up a threshold",
                                   " visualized here as the grey line."),
         width = 70))
```
However, the length also greatly varies for copies for which we were able to detect one or two of the flanking genes on the same contig.
```{r}


p1 = dim2_blast_results %>%
  ggplot(aes(length, fill = is_same_contig, color = is_same_contig)) +
    geom_density(alpha = 0.7) +
    theme_bw() +
    labs(x = "Length (bp)",
         y = "Density",
         title = str_wrap("Length of all blast matches against Zt10dim2", width = 30))


p3 = dim2_blast_results %>%
  ggplot(aes(Nb_flanking_found_2cat, fill = is_same_contig)) +
    geom_bar(alpha = 0.7) +
    theme_bw() +
  labs ( x = "Number of flanking genes on the same contig",
         y = "Number of copies",
         title = str_wrap("Numbers of copies found in the same contig as the flanking genes ", width = 30)) +
  theme(legend.position = "none")

legend_b <- get_legend(
  p1 +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)

prow <- plot_grid(
  p1 + theme(legend.position="none"),
  p3 + theme(legend.position="none"),
  align = 'vh',
  labels = c("A", "B"),
  hjust = -1,
  nrow = 1)

plot_grid(prow, legend_b, ncol = 1, rel_heights = c(1, .1))

```

Now, I will select only the copies which have a least one flanking gene found on the same contig. I consider these the "native" copy of the gene. And I will then make some plots using only these original copies to investigate the geographical distribution of both length and identity with the dim2 copy of Zt10.
```{r}

temp = dim2_blast_results %>%
  group_by(sample) %>%
  dplyr::summarize(n_matches = n(),
                   n_long_matches = sum(length > 1000))

sum_dim2_blast = dim2_blast_results %>%
  dplyr::filter(Nb_flanking_found_2cat == ">1") %>%
  group_by(sample) %>%
  dplyr::summarize(length_sum = sum(length),
                   pident_wm = weighted.mean(pident, length),
                   n_matches_on_native_contigs = n()) %>%
  filter(length_sum < length_dim2 + 200) %>%
  inner_join(., temp) %>%
  inner_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file"))



#Plots of identity vs length of the original copy
scatter <- sum_dim2_blast %>%
  ggplot(aes(length_sum, pident_wm,
             color = Continent,
             shape = as.character(n_matches_on_native_contigs))) +
  geom_point() +
  theme_bw() + Color_Continent +
  theme(legend.position = "none") +
  labs( x = "Length of the recovered native copy",
        y = "Identity with Zt10dim2")

hist_top = sum_dim2_blast %>%
  filter(Continent != "Asia") %>%
  ggplot(aes(Continent, length_sum,
             fill = Continent, color = Continent)) +
  geom_boxplot(alpha = 0.6, width = 0.4) +
  theme_bw() +
  Fill_Continent + Color_Continent+
  theme(legend.position = "none",
        axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7)) +
  coord_flip() +
  labs( x = "", y = "")

hist_right = sum_dim2_blast %>%
  filter(Continent != "Asia") %>%
  ggplot(aes(Continent, pident_wm, fill = Continent)) +
  geom_violin(alpha = 0.6) +
  theme_bw() + Fill_Continent +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 7, angle = 20, hjust = 1)) +
  labs( x = "", y = "")


#Options for top right plot
legend_b <- get_legend(
  hist_top +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "right")
)

empty <- ggplot()+geom_point(aes(1,1), colour="white")+
         theme(axis.ticks=element_blank(),
               panel.background=element_blank(),
               axis.text.x=element_blank(), axis.text.y=element_blank(),           
               axis.title.x=element_blank(), axis.title.y=element_blank())




#Gather all
cowplot::plot_grid(hist_top, legend_b, scatter, hist_right,
                   ncol=2, nrow=2,
                   rel_widths=c(1.2, 1), rel_heights=c(1, 1),  
                   align = 'vh')

```

```{r}
sum_dim2_blast %>%
  filter(Continent != "Asia") %>%
  dplyr::mutate(Nb_frag = as.character(n_matches_on_native_contigs))  %>%
  dplyr::count(Nb_frag, Collection, Continent) %>%
  ggplot(aes(Collection, Continent, color = Collection)) +
  geom_point(aes(size = n), stat = "identity", alpha = 0.6) +
  theme_bw() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 7, angle = 20, hjust = 1)) +
  labs( x = "", y = "") +
  Fill_Continent +
  facet_wrap(vars(Nb_frag))
```
Here a large proportion of the Middle-Eastern samples from the old Hartmann dataset have two matches on the "right" contigs: this is due to a deletion found in one of the allele of dim2 (shown in Mareike's new version of her dim2 manuscript).

Let's investigate quickly how many long copies there are in each genome. I'm also interested in the native match as related to RIP and geography.
```{r RIP vs dim2}

p1 = sum_dim2_blast %>%
  ggplot(aes(as.numeric(Composite_median), pident_wm, color = Continent,
                      shape = Collection))+
  geom_point() + Color_Continent +
  theme_bw() + theme(legend.position = "none") +
    labs(x = str_wrap(paste("RIP composite index",
                            " (median per isolate)"),
                      width = 20),
         y = str_wrap("Identity of the native match",
                      width = 20))

p2 = sum_dim2_blast %>%
  ggplot(aes(as.numeric(Composite_median), n_long_matches, color = Continent,
                      shape = Collection))+
  geom_point() + Color_Continent +
  theme_bw() + theme(legend.position = "none") +
    labs(x = str_wrap(paste("RIP composite index",
                            " (median per isolate)"),
                      width = 20),
         y = str_wrap("Number of long blast matches (above 1kb)",
                      width = 20))

p3 = sum_dim2_blast %>%
  ggplot(aes(x = pident_wm, y = n_long_matches, color = Continent,
                      shape = Collection)) +
  geom_point() + Color_Continent + theme_bw()+
    labs(x = str_wrap("Identity of the native match",
                      width = 20),
         y = str_wrap("Number of long blast matchess (above 1kb)",
                      width = 20),
         color = "Geographical group") +
  theme(axis.title=element_text(size=10))

bottom_row <- cowplot::plot_grid(p1, p2, labels = c('B', 'C'), label_size = 12)


cor.test(sum_dim2_blast$pident_wm, sum_dim2_blast$Composite_median, method="spearman")
cor.test(sum_dim2_blast$n_long_matches, sum_dim2_blast$Composite_median, method="spearman")
cor.test(sum_dim2_blast$pident_wm, sum_dim2_blast$n_long_matches, method="spearman")

cowplot::plot_grid(p3, bottom_row, labels = c('A', ''), label_size = 12, ncol = 1)

```
```{r RIP vs dim2 separate Hartman}

p1 = sum_dim2_blast %>%
  filter(Collection == "Hartmann") %>%
  ggplot(aes(as.numeric(Composite_median), pident_wm, color = Continent))+
  geom_point() + Color_Continent +
  theme_bw() + theme(legend.position = "none") +
    labs(x = str_wrap(paste("RIP composite index",
                            " (median per isolate)"),
                      width = 20),
         y = str_wrap("Identity of the native match",
                      width = 20))

p2 = sum_dim2_blast %>%
  filter(Collection != "Hartmann") %>%
  ggplot(aes(as.numeric(Composite_median), pident_wm, color = Continent))+
  geom_point() + Color_Continent +
  theme_bw() + theme(legend.position = "none") +
    labs(x = str_wrap(paste("RIP composite index",
                            " (median per isolate)"),
                      width = 20),
         y = str_wrap("Identity of the native match",
                      width = 20))

cowplot::plot_grid(p1, p2, labels = c('A', 'B'), label_size = 12)


```
```{r}

#Statistical test
#One-way ANOVA with blocks
##Define linear model
model = lm(as.numeric(pident_wm) ~ Continent + Collection ,
          data=sum_dim2_blast)
summary(model)   ### Will show overall p-value and r-squared

##Conduct analysis of variance
Anova(model,type = "II")  
summary(model)

hist(residuals(model), col="darkgray")

#Post-hoc analysis:  mean separation tests
marginal = lsmeans(model, ~ Continent)

pairs(marginal, adjust="tukey")

CLD_dim = cld(marginal,
          alpha   = 0.05,
          Letters = letters,  ### Use lower-case letters for .group
          adjust  = "tukey")  ### Tukey-adjusted p-values

CLD_dim

CLD_dim$.group=gsub(" ", "", CLD_dim$.group)

text_y = (max(as.numeric(temp$Composite_median), na.rm = T) + 0.1*max(as.numeric(temp$Composite_median), na.rm = T))


```


And then as boxplots per continental region.
```{r dim2 blast results box}
p1 = sum_dim2_blast %>%
  group_by(Continent) %>%
  dplyr::mutate(avg_per_cont = mean(pident_wm, na.rm = T)) %>%
  ggplot(aes(Continent, pident_wm,
             fill = Continent)) +
  geom_violin(aes(fill = Continent), alpha = 0.5) +
    geom_jitter(aes(col = Continent), size = 0.8, alpha = 0.8, width = 0.2, height = 0.1) +
  Fill_Continent + Color_Continent  +
    theme_light() +
    theme(
    panel.border = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none",
    axis.text.x = element_text(size = 10, angle = 40, hjust = 1)) +
   coord_flip() +
  labs(x = NULL,
       y = "Identity of the native copy to Zt10dim2") +
  geom_text(data = CLD_dim, aes(x = Continent,
                            y = 102,
                            label = .group), color = "black")


p2 = ggplot(sum_dim2_blast, aes(Continent, n_long_matches,
             fill = Continent)) +
  geom_violin() + Fill_Continent +
  theme_light() +
  theme(panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none",
    axis.text.x = element_text(angle = 40, hjust = 1))+
  labs(x = NULL,
       y = "Number of dim2 copies") + coord_flip()
cowplot::plot_grid(p1, p2, rel_widths = c(1, 1))



```

## dim2 tree
```{r}

# TODO
# Use beginning and end of dim2 gene (100bp) to get gene boundaries on assemblies.
# Update: I tried. But it really does not work better...
#Here is the code of the comparison in case I need to use it later still

#Selecting start and end coordinates which are found on a contig
# with at least one of the flanking genes.
dim2_start = dim2_blast_results_complete %>%
  filter(gene == "dim2_start") %>%
  full_join(., flank1) %>%
  full_join(., flank2) %>%
  mutate(dim2_flank1 = replace_na(dim2_flank1, "Not_found"),
         dim2_flank2 = replace_na(dim2_flank2, "Not_found")) %>%
  mutate(is_same_contig = ifelse(sseqid == dim2_flank1 & sseqid == dim2_flank2,
                                 "Both",
                                 ifelse(sseqid != dim2_flank1 & sseqid != dim2_flank2,
                                 "None",
                                 ifelse(sseqid == dim2_flank1, "Flank1",
                                 ifelse(sseqid == dim2_flank2, "Flank2", "What")))))%>%
  mutate(Nb_flanking_found_2cat = ifelse(is_same_contig == "None", "0", ">1"))%>%
  filter(Nb_flanking_found_2cat == ">1")

dim2_end = dim2_blast_results_complete %>%
  filter(gene == "dim2_end") %>%
  full_join(., flank1) %>%
  full_join(., flank2) %>%
  mutate(dim2_flank1 = replace_na(dim2_flank1, "Not_found"),
         dim2_flank2 = replace_na(dim2_flank2, "Not_found")) %>%
  mutate(is_same_contig = ifelse(sseqid == dim2_flank1 & sseqid == dim2_flank2,
                                 "Both",
                                 ifelse(sseqid != dim2_flank1 & sseqid != dim2_flank2,
                                 "None",
                                 ifelse(sseqid == dim2_flank1, "Flank1",
                                 ifelse(sseqid == dim2_flank2, "Flank2", "What")))))%>%
  mutate(Nb_flanking_found_2cat = ifelse(is_same_contig == "None", "0", ">1"))%>%
  filter(Nb_flanking_found_2cat == ">1")


# Table from start/end
#full_join(dim2_start, dim2_end, by = "sample") %>%
#  filter(complete.cases(.)) %>%
#  select(sample, dim2_flank1.x, dim2_flank2.x,
#         gene.x, sseqid.x, sstart.x, send.x, is_same_contig.x, Nb_flanking_found_2cat.x,
#         gene.y, sseqid.y, sstart.y, send.y, is_same_contig.y, Nb_flanking_found_2cat.y) %>%
#  left_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file")) %>%
#  group_by(is_same_contig.x, Continent) %>%
#  dplyr::summarise(n()) %>%
#  pivot_wider(names_from = Continent, values_from = `n()`)

# Table from the "simple" blast as comparison
#dim2_blast_results %>%
#  dplyr::filter(Nb_flanking_found_2cat == ">1") %>%
#  left_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file")) %>%
#  filter(length > 2500) %>%
#  dplyr::count(is_same_contig, Continent) %>%
#  pivot_wider(names_from = Continent, values_from = n)

#Keep only copies with:
#   - both flanking genes
#   - one flanking gene but a length of 2500 at least

dim2_blast_results %>%
  dplyr::filter(Nb_flanking_found_2cat == ">1") %>%
  left_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file")) %>%
  filter(length > 2500) %>%
  dplyr::count(is_same_contig, Continent) %>%  
  dplyr::group_by(Continent) %>%
  dplyr::mutate(Somme_per_collection = sum(n)) %>%
  mutate(prop = n*100/Somme_per_collection) %>%
  ggplot(aes(x = is_same_contig, y = Continent, fill = prop)) +
    geom_tile() +
    theme_bw() +
    scale_fill_viridis_c() +
  labs (title = str_wrap(paste0("Proportion of long dim2 matches ",
                                "with at least one flanking gene"),
                         width = 70))

#Write the bed file to extract the sequences
dim2_blast_results %>%
  dplyr::filter(Nb_flanking_found_2cat == ">1") %>%
  left_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file")) %>%
  dplyr::filter(length > 2500) %>%
  dplyr::mutate(start = ifelse(sstart > send, send, sstart),
                end = ifelse(sstart > send, sstart, send)) %>%
  dplyr::select(sample, sseqid, start, end) %>%
  write_delim(paste0(TE_RIP_dir, "Coordinates_dim2_all_samples.bed"),
            col_names = F)


#This command has to be run on the cluster
#while read sample chr start end ; do
# echo -e "${chr}\t${start}\t${end}" > temp.bed ;
# ~/Software/bedtools getfasta \
#    -fi /data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/0_Spades/${sample}.fasta \
#    -bed temp.bed | sed "s/>/>${sample}:/" >> \
#    /data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/1_Blast_dim2_deRIPped/Native_dim2_all_samples.fasta ;
#done < /data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/1_Blast_dim2_deRIPped/Coordinates_dim2_all_samples.bed

#Run through the website because laziness
# mafft --thread 8 --threadtb 5 --threadit 0 --reorder --adjustdirection --auto input > output
```

For the following tree, I used the gene alignment from mafft (online) and created a neighbor-joining tree. The gene sequence from Z. passerinii was used as the outgroup sequence. Then, I attempt to represent both the geographical origin or the samples and the RIP level.
```{r dim2 tree plots}

#Prep data to add to tree
temp2 = dim2_blast_results %>%
  dplyr::filter(Nb_flanking_found_2cat == ">1") %>%
  left_join(., RIP %>% filter(TE == "RIP_est"), by = c("sample" = "ID_file")) %>%
  dplyr::filter(length > 2500) %>%
  dplyr::mutate(start = ifelse(sstart > send, send, sstart),
                end = ifelse(sstart > send, sstart, send)) %>%
  unite(coord, start, end, sep = "-") %>%
  dplyr::mutate(no_dot = stringr::str_replace(sseqid, "\\.", "_"))%>%
  unite(contig2, sample, no_dot, coord, sep = "_", remove = F)


#Read tree in
#details from the mafft website about the tree
#Size = 237 sequences × 1214 sites
#Method = Neighbor-Joining
#Model = Jukes-Cantor
#Bootstrap resampling = 100

tree = as_tibble(treeio::read.tree("/Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/Essai_dim2_tree.nwk")) %>%
  mutate(label_copy = label) %>%
  separate(label_copy, into = c("nb", "contig"), extra = "merge", remove =F) %>%
  dplyr::mutate(nb = as.integer(nb)) %>%
  dplyr::mutate(label_OG = label) %>%
  dplyr::mutate(contig2 = stringr::str_replace(contig, "R_", "")) %>%
  full_join(., temp2, by = c("contig2")) %>%
  dplyr::mutate(label_temp = ifelse(is.na(sample), ifelse(is.na(contig), label, contig), sample)) %>%
  unite(col = "label_new", nb, label_temp, sep = "_")

tree2 = as_tibble(treeio::read.tree("/Users/feurtey/Documents/Postdoc_Bruce/Projects/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/Essai_dim2_tree.nwk"))

temp = tree %>%
  dplyr::select(label, node, label_new, Continent, Composite_median, Collection) %>%
  mutate(Composite_median = ifelse(is.na(Composite_median), 0, Composite_median)) %>%
  filter(!is.na(label)) %>%
  mutate(RIP = ifelse(Composite_median >= 1.5, "High", ifelse(Composite_median <= 1, "Low", "Medium")))

#Find the outgroup!
root_node = tree2 %>%
  filter(grepl("Zpa63", label)) %>%
  dplyr::select(node) %>%
  pull()


rooted.tree <- ape::root(as.treedata(tree2), root_node)
p <- ggtree(rooted.tree, layout = "rectangular") %<+% (temp %>% dplyr::select (-label))

p2 <- p + geom_tippoint(aes(color = Continent)) +
  theme(legend.position = "right") +
  Color_Continent

p3 <- p + geom_tippoint(aes(color = RIP), alpha = 0.5) +
  theme(legend.position = "right") +
  scale_color_manual(values = c("darkred", "yellow", "orange"))

p4 <- p + geom_tippoint(aes(color = Collection), alpha = 0.5) +
  theme(legend.position = "right")

cowplot::plot_grid(p2, p3)


df = temp %>% dplyr::select(RIP)
rownames(df) <- temp$label
gheatmap(p2, df, width=.2) +
  scale_fill_manual(values = c("darkred", "yellow", "orange"), name = "RIP") +
  labs(title = "Gene tree for the dim2 sequence",
       y = "")



```

Based on these trees, there is some clustering according to geography. Additionally, it looks like the Middle-Eastern samples have either a high or low RIP level on their TE, whereas the level is rather in the middle of the range elsewhere...




## Gene duplication and RIP

### PacBio samples from the pangenome

If there is a relaxation of RIP, we could expect that TEs would not be the only things impacted but that gene duplications would also be possible more in RIP-relaxed genomes than in RIP-active.
```{r}
Badet_pan_table = read_tsv(paste0(TE_RIP_dir, "Badet_GLOBAL_PANGENOME_TABLE.txt"))

Badet_pan_table %>%
  dplyr::select(isolate, orthogroup, N_genes, N_isolates, cat) %>%
  group_by(isolate) %>%
  dplyr::mutate(nb_genes = n()) %>%
  group_by(isolate, N_genes) %>%
  dplyr::summarize(count = n(), nb_genes = mean(nb_genes)) %>%
  dplyr::mutate(Percent = 100 * count / nb_genes) %>%
  dplyr::filter(N_genes >= 2) %>%
  dplyr::filter(N_genes <= 10) %>%
  ggplot(aes(isolate, Percent, fill = N_genes)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1)) +
  scale_fill_gradient(low = "#EAEAEA", high = "#294D4A", na.value = NA)

Badet_pan_table %>%
  dplyr::select(isolate, orthogroup, N_genes, N_isolates, cat) %>%
  group_by(isolate) %>%
  dplyr::mutate(nb_genes = n()) %>%
  dplyr::filter(N_genes >= 2) %>%
  dplyr::mutate(N_genes_cat = ifelse(N_genes >= 9, "9 +", as.character(N_genes))) %>%
  group_by(isolate, N_genes_cat) %>%
  dplyr::summarize(count = n(), nb_genes = mean(nb_genes)) %>%
  dplyr::mutate(Percent = 100 * count / nb_genes) %>%
  ggplot(aes(isolate, Percent, fill = N_genes_cat)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))

Badet_pan_table %>%
  dplyr::select(isolate, orthogroup, N_genes, N_isolates, cat) %>%
  group_by(isolate) %>%
  dplyr::mutate(nb_genes = n()) %>%
  dplyr::filter(N_genes >= 2) %>%
  dplyr::mutate(N_genes_cat = ifelse(N_genes >= 9, "9 +", as.character(N_genes))) %>%
  group_by(isolate, N_genes_cat) %>%
  dplyr::summarize(count = n(), nb_genes = mean(nb_genes)) %>%
  dplyr::mutate(Percent = 100 * count / nb_genes) %>%
  dplyr::filter(N_genes_cat == 2) %>%
  ggplot(aes(isolate, Percent, fill = N_genes_cat)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))
```  

### On Illumina samples
```{R}
temp = inner_join(sum_dim2_blast, duplicated_genes, by = c("sample" = "ID_file", "Continent")) %>%
  filter(Nb_duplicated_genes < 400)


p1 = ggplot(temp, aes(as.numeric(Composite_median),
                      Nb_duplicated_genes,
                      color = Continent,
                      shape = Collection))+
  geom_point() + Color_Continent +
  theme_bw()  +
    labs(x = str_wrap(paste("RIP composite index",
                            " (median per isolate)"),
                      width = 20),
         y = str_wrap("Number of duplicated genes",
                      width = 20))

p2 = ggplot(temp, aes(pident_wm,
                      Nb_duplicated_genes,
                      color = Continent,
                      shape = Collection))+
  geom_point() + Color_Continent +
  theme_bw() + theme(legend.position = "none") +
    labs(x = str_wrap(paste("Identity of the native match"),
                      width = 20),
         y = str_wrap("Number of duplicated genes",
                      width = 20))

legend_b <- get_legend(
  p1 +
    theme(legend.position = "right")
)
top = cowplot::plot_grid(p1+ theme(legend.position = "none"), p2, ncol = 1)
cowplot::plot_grid(top, legend_b, nrow = 1)
```


<br><br>




# Adaptation to local climatic conditions
***
For the following points, different types of data need to be collected.

__Genomic data__: ideally, we would work from both SNPs and CNV of genes as much as possible (not including TE at the moment, because too complex/uncertain?) + Add the structural variants if/when we can detect them from Illumina data?

__Geographic/environmental data__: For this, I will use the sampling site of each isolate (as precisely as I can manage) to approximate environmental parameters such as temperature, precipitation or solar radiation. One possibility to find such data is this website, https://www.worldclim.org/data/worldclim21.html (published in Fick and Hijmans, 2017), which gives access to climate data for 1970-2018. These can be transformed into bioclimatic variables using the biovars function from the R package dismo (https://rdrr.io/cran/dismo/man/biovars.html).

```{r Get Bioclim data}

temp = Zt_meta %>%
  filter(!(ID_file %in% filtered_samples$ID_file)) %>%
  filter(!is.na(Longitude)) %>%
  mutate(X = as.numeric(unlist(Longitude)),
                            Y = as.numeric(unlist(Latitude))) %>%
  dplyr::select(X, Y) %>%
  distinct()

sp = SpatialPoints(temp[, c("X", "Y")])
summary(sp)

#Bioclim data (from Worldclim)
Bioclim_var = c("Annual Mean Temperature", "Mean Diurnal Range ",
                "Isothermality (BIO2/BIO7) (×100)", "Temperature Seasonality (standard deviation ×100)",
                "Max Temperature of Warmest Month", "Min Temperature of Coldest Month",
                "Temperature Annual Range (BIO5-BIO6)",
                "Mean Temperature of Wettest Quarter","Mean Temperature of Driest Quarter",
                "Mean Temperature of Warmest Quarter", "Mean Temperature of Coldest Quarter",
                "Annual Precipitation", "Precipitation of Wettest Month",
                "Precipitation of Driest Month", "Precipitation Seasonality (Coefficient of Variation)",
                "Precipitation of Wettest Quarter", "Precipitation of Driest Quarter",
                "Precipitation of Warmest Quarter","Precipitation of Coldest Quarter)")

bio_list = list()
for (i in c(1:length(Bioclim_var))) {
  file_name=paste0(data_dir,"Climatic_data/wc2.1_10m_bio/wc2.1_10m_bio_", i, ".tif")
  rast_temp = raster(file_name)    
  bio_list[[Bioclim_var[i]]] = raster::extract(rast_temp, sp)
}

#Adding solar radiations
sol_list = list()
for (i in c(1:12)) {
  file_name=paste0(data_dir,"Climatic_data/wc2.1_10m_srad/wc2.1_10m_srad_", str_pad(i, 2, pad ="0"), ".tif")
  rast_temp = raster(file_name)    
  sol_list[[i]] = raster::extract(rast_temp, sp)
}
sol_months = cbind(temp, do.call(cbind, sol_list))
sol_months$srad_max = apply(sol_months[, c(3:ncol(sol_months))], 1, max)
sol_months = sol_months %>% dplyr::select(X,Y, srad_max)


climate_per_coordinates = cbind(temp, do.call(cbind, bio_list)) %>%
  full_join(., sol_months)

```

```{r Plot distrib bioclim}

dat = Zt_meta %>%
  filter(!(ID_file %in% filtered_samples$ID_file)) %>% 
  dplyr::select(ID_file, Latitude, Longitude, Continent) %>%
  full_join(., climate_per_coordinates,
                by= c("Longitude" = "X", "Latitude" = "Y")) %>%
  dplyr::select(-ID_file) %>%
  gather(key = "Bioclim_var", value = "Estimate", -c(Longitude, Latitude, Continent))

#Define stable colors
#myColors = c("#ec9a29", "#0f8b8d", "#143642")
#names(myColors) = levels(factor(dat$Continent))
#colScale = scale_colour_manual(name = "Continent", values = myColors)
#colScaleFill = scale_fill_manual(name = "Continent", values = myColors)

ggplot(dat, aes(Estimate, fill =Continent, color =Continent)) +
  geom_histogram(position = "stack") +
  facet_wrap(.~Bioclim_var, scales = "free") +
  theme_classic() + Color_Continent + Fill_Continent


```

Naturally, many of the variables investigated above are highly correlated. It is intuitive for example that the minimum temperature of the coldest month would be correlated to the average temperature of the coldest quarter! Here, I visualize these correlations.

```{r correl climate var}

#Correlogram

Ccor = cor(climate_per_coordinates)
corrplot(Ccor, type="lower", order="hclust",
         col = mycolorsCorrel,
         tl.col="black", tl.srt=45, tl.cex = 0.7)

#Simple heatmap
heatmap(x = Ccor, col = mycolorsCorrel, symm = TRUE)
```


__How to choose the best variables?__

* Only keep one per "correlation block"?
* Create composite variables with a PCA? Only meaningful if we can interpret the principal component.

```{r PCA bioclim var}

country_climate = Zt_meta %>%
  filter(!(ID_file %in% filtered_samples$ID_file)) %>% 
  filter(!is.na(Longitude)) %>%
  dplyr::select(Latitude, Longitude, Continent) %>% 
  unique()
bioclim.pca <- prcomp(climate_per_coordinates[,c(2:ncol(climate_per_coordinates))], scale. = TRUE)
ggbiplot(bioclim.pca, obs.scale = 1, var.scale = 1,
         group = country_climate$Continent, ellipse = TRUE) +
  Color_Continent +
  theme(legend.direction = 'horizontal', legend.position = 'top') +
  xlim(-25, 10) + ylim(-15, 25)
```


```{r}


tidy_cors <- climate_per_coordinates %>%
  dplyr::select(everything(), -contains("uarter"), -Y, -X) %>%
  correlate() %>%
  stretch()

graph_cors <- tidy_cors %>%
  filter(abs(r) > .3) %>%
  graph_from_data_frame(directed = FALSE)

ggraph(graph_cors) +
  geom_edge_link(aes(edge_alpha = .5, edge_width = abs(r), color = r)) +
  guides(edge_alpha = "none", edge_width = "none") +
  scale_edge_colour_gradientn(limits = c(-1, 1), colors = c("#0f8b8d", "#a8201a")) +
  geom_node_point(color = "black", size = 3) +
  geom_node_text(aes(label = name), repel = TRUE) +
  theme_graph() +
  labs(title = "Correlations between bioclimatic variables")


```


## GEA: genotype-environment association
__Methods__: Several software to explore:

 * Lfmm: http://membres-timc.imag.fr/Olivier.Francois/lfmm/index.htm This method claim to identify genetic polymorphisms exhibiting high correlation with environmental gradients (or phenotypic traits) while controlling for confounding effects such as population structure.

```{bash, eval =F}
datamash transpose \
    < ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2 \
    > ${GEADIR}$VCFNAME.pass_noNA.GT.FORMAT2.transposed
```

```{bash format lfmm, eval = F}

vcftools --vcf ${VCFDIR}$VCFNAME.recode.vcf \
  --keep $ZTLIST \
  --remove-filtered-all --extract-FORMAT-info GT \
  --max-missing 1.0 --min-alleles 2 --max-alleles 2 \
  --maf 0.05 \
  --out ${POPSTR}$VCFNAME.pass_noNA


cat  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT | cut -f 3- \
    > ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2
cat  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT | cut -f 1,2 \
    > ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT.pos
head -n1 ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2 | gsed "s/\t/\n/g"  \
    > ${POPSTR}$VCFNAME.pass_noNA.ind
gsed "s/\t//g"  ${POPSTR}$VCFNAME.pass_noNA.GT.FORMAT2 | tail -n +2 \
    > ${POPSTR}$VCFNAME.pass_noNA.geno

```

```{r standard Bioclim var}

#Create standardized values for the environment variables

climate_per_coord_standard = climate_per_coordinates %>%
  pivot_longer(cols = -c(X, Y), names_to = "Variable_climate", values_to = "Value") %>%
  group_by(Variable_climate) %>%
  mutate(Standard_value = scale(Value)) %>%
  dplyr::select(-Value) %>%
  pivot_wider(names_from = Variable_climate, values_from = Standard_value)


```



```{r GEMMA prep climate file, eval = F}
#Convert one random vcf file to binary ped format and accompagnying files
#./plink \
#    --vcf /data2/alice/WW_project/1_Variant_calling/4_Joint_calling/Ztritici_global_December2020.genotyped.2.filtered.clean.good_samples.SNP.max-m-0.8.recode.vcf.gz \
#    --make-bed \
#    --out /data2/alice/WW_project/5_GEA/Ztritici_global_December2020.genotyped.2.filtered.clean.good_samples.SNP.max-m-0.8 \
#  --double-i

#The fam file should be same for all core chromosomes, hopefully. So I only have to transform one to get the file format including the phenotypes. This can then be used for all chromosomes.

temp = read_delim("~/Documents/Postdoc_Bruce/Projects/WW_project/5_GEA/Ztritici_global_December2020.genotyped.2.filtered.clean.good_samples.SNP.max-m-0.8.fam", delim = " ", col_names = F)
 
 
temp2 = left_join(Zt_meta %>% dplyr::select(ID_file, Latitude, Longitude), 
                   climate_per_coord_standard,
                   by = c("Latitude" = "Y", "Longitude" = "X")) %>%
               right_join(., indv_snmf,
               tibble(name = target), by = c("ID_file" = "Sample")) 
 

 full_join(temp, temp2, by = c("X1"="ID_file")) %>% dplyr::select(-X6, -Latitude, -Longitude) %>%
   write_delim(., 
               "~/Documents/Postdoc_Bruce/Projects/WW_project/5_GEA/Ztritici_global_December2020.genotyped.2.filtered.clean.good_samples.SNP.max-m-0.8.with_climatic_variables.fam", 
               delim = " ", col_names = F)

#Transfer on the cluster
#---------------
#rsync -avP \
#   ~/Documents/Postdoc_Bruce/Projects/WW_project/5_GEA/Ztritici_global_December2020.genotyped.2.filtered.clean.good_samples.SNP.max-m-0.8.with_climatic_variables.fam \
#  alice@130.125.25.244:/data2/alice/WW_project/5_GEA/Phenotypes_with_climatic_variables.fam
 
 
#To run gemma on the cluster: conda activate env0
#Commands are then in the format gemma -h 
```

```{r GEMMA results}
results_GEMMA = list()
for (i in c(1:length(Bioclim_var))) {
  temp = list.files(path = GEA_dir, pattern = paste0("*_for_phenotype_", i,".assoc.txt")) %>% 
    map_df(~read_tsv(file = paste0(GEA_dir, .))) %>%
    unite(col = SNP, chr, ps, sep = "_", remove = F) %>%
    dplyr::select(SNP, CHR = chr, BP = ps, P = p_wald, zscore = logl_H1) %>%
    mutate(Phenotype = Bioclim_var[i], Nb = i)
  results_GEMMA[[Bioclim_var[i]]] = temp
  print(i)
  print(Bioclim_var[i])
  print(dim(temp))
}

results_GEMMA = bind_rows(results_GEMMA)

core_temperature_variable = c("Annual Mean Temperature", 
                          "Max Temperature of Warmest Month", "Mean Temperature of Warmest Quarter",
                          "Min Temperature of Coldest Month", "Mean Temperature of Coldest Quarter")

core_rain_variable = c("Annual Precipitation", 
                "Precipitation of Wettest Month", "Precipitation of Driest Month", 
                "Precipitation of Wettest Quarter", "Precipitation of Driest Quarter")
```

```{r}
max_SNPs = results_GEMMA %>%
  mutate(logP = -log10(P)) %>%
  group_by(Nb, Phenotype) %>%
  slice_max(logP, prop = .0001) %>%
  dplyr::select(SNP, Phenotype) %>%
  mutate(SNP_type = "MAX")
```


```{r GEMMA prep plot}
# Compute chromosome size and cumulative position of each chromosome
results_GEMMA_for_plot <- results_GEMMA %>% 
  group_by(CHR) %>% 
  dplyr::summarise(chr_len=max(BP)) %>% 
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  dplyr::select(-chr_len) 

#EStimate middle of chromosome to center the labels
axisdf = results_GEMMA_for_plot %>%
  inner_join( ., results_GEMMA %>% filter(Nb == 1)) %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>% 
  group_by(CHR) %>% 
  dplyr::summarise(center=( max(BPcum) + min(BPcum) ) / 2 )
```

```{r GEMMA plot core temp}
# Manhattan plot for core temperature variable

pheno = "Max Temperature of Warmest Month"

temp = results_GEMMA %>% filter(Phenotype == pheno) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  left_join(., max_SNPs %>% dplyr::filter(Phenotype == pheno)) %>%
  mutate(SNP_type = ifelse(is.na(SNP_type), "Other", SNP_type)) %>%
  mutate(logP = -log10(P)) 
  
p = temp %>%
  ggplot(., aes(x=BP, y=logP)) +
    geom_point( aes(color=SNP_type), alpha = 0.8, size=1.3) +
    scale_color_manual(values = c("#F28482", "#F5B9B3")) +
    geom_hline(aes(yintercept=min(temp[temp$SNP_type == "MAX",]$logP)),
               linetype = "dashed", color = "grey20") +
    theme_bw() +
    theme( legend.position="none", panel.border = element_blank(),
      panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
      axis.title.x=element_blank(), axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
      strip.background = element_rect(colour="white", fill="white"),
      plot.margin = unit(c(0, 0, 0, 0), "cm")) +
  facet_grid(cols = vars(CHR), scales = "free_x") +
  labs(y = str_wrap("Max Temperature of Warmest Month (-logP)", 25))



pheno = "Min Temperature of Coldest Month"

temp2 = results_GEMMA %>% filter(Phenotype == pheno) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  left_join(., max_SNPs %>% dplyr::filter(Phenotype == pheno)) %>%
  mutate(SNP_type = ifelse(is.na(SNP_type), "Other", SNP_type)) %>%
  mutate(logP = -log10(P)) 

q = temp2 %>%
  ggplot(., aes(x=BP, y=logP)) +
    geom_point( aes(color=SNP_type), alpha = 0.8, size=1.3) +
    scale_color_manual(values = c("#0889D9", "#C4E7FD")) +
    geom_hline(aes(yintercept=min(temp2[temp2$SNP_type == "MAX",]$logP)),
               linetype = "dashed", color = "grey20") +
    theme_bw() +
    theme( legend.position="none", panel.border = element_blank(),
      panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
      axis.text.x = element_text(angle = 60, hjust = 1),
      strip.background = element_blank(), strip.text.x = element_blank(),
      panel.spacing.x = unit(0.4, "lines"),
      plot.margin = unit(c(0, 0, 0, 0), "cm")) +
  facet_grid(cols = vars(CHR), scales = "free_x") +
  scale_y_reverse() +
  labs(y = str_wrap("Min Temperature of Coldest Month (-logP)", 25))

cowplot::plot_grid(p, q, nrow = 2)
```


```{r}
#  Manhattan plot for core precipitation
results_GEMMA %>% filter(Phenotype %in% core_rain_variable) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
  ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype), scales = "free_y")
```

```{r GEMMA plot 01}
#Manhattan plot
results_GEMMA %>% filter(Nb <= 4) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype), scales = "free_y")
```

```{r GEMMA plot 02}
results_GEMMA_for_plot %>%
  inner_join( ., results_GEMMA %>% filter(Nb > 4 & Nb <= 8))  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype))
```

```{r  GEMMA plot 03}

results_GEMMA %>% 
  filter(Nb > 8 & Nb <= 12) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype))

```

```{r  GEMMA plot 04}

results_GEMMA %>% 
  filter(Nb > 12 & Nb <= 16) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype))
```

```{r  GEMMA plot 05}

results_GEMMA %>% 
  filter(Nb > 16 ) %>%
  inner_join(., results_GEMMA_for_plot)  %>%
  arrange(CHR, BP) %>%
  mutate(BPcum = BP+tot) %>%
ggplot(., aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    ) +
  labs(x = "", title = "Manhattan plots") +
  facet_grid(rows = vars(Phenotype))
```



<br><br>


# Fungicide resistance
***

This is based on the same scripts made for Fanny Hartmann's paper on the pairs of populations: looking for alleles already known to be involved in resistance to fungicide.

```{r}
genotypes_resistance = read_tsv(paste0(fung_dir, "genotypes_tidy_format.tab"),
                                col_names = c("temp", "ID_file", "Allele")) %>%
  separate(temp, into = c("Gene", "AA_change"), sep = "\\.") %>%
   dplyr::mutate(AA_REF = str_sub(AA_change, 1, 1)) %>%
  dplyr::mutate(Allele_type = ifelse(AA_REF == Allele, "Origin", "Mutant")) %>%
  left_join(Zt_meta)


genotypes_resistance %>%
  dplyr::count(AA_change, Gene, Allele_type) %>%
  ggplot(aes(x=n, y=AA_change, fill = Allele_type)) +
  geom_barh(stat="identity") +
  facet_grid(Gene ~ ., scales = "free_y", space = "free_y")



```

I suspect that there will be an effect of both geography and time on the frequency of these alleles and so I try to represent this here.


```{r fungicides bubble plots}
#CYP51
temp = genotypes_resistance %>%
  filter(Gene == "CYP51") %>%
  dplyr::count(AA_change, Continent,Sampling_Date, Allele_type) %>%
  pivot_wider(names_from = Allele_type, values_from = n, values_fill = list(n = 0)) %>%
  mutate(prop_mutant = Mutant/(Mutant + Origin)) %>%
  filter(!is.na(Sampling_Date)) %>%
  filter(!is.na(Continent)) %>%
  group_by(AA_change) %>%
  dplyr::mutate(Somme = sum(Mutant)) %>%
  filter(Somme > 0)

temp %>%
  ggplot(aes(x=Sampling_Date, y=Continent, size = prop_mutant, fill = prop_mutant)) +
  geom_point(shape=21, col = myColors[3], alpha =0.7) + theme_bw() +
  facet_wrap(.~AA_change) + scale_fill_gradient(low="white", high = "#16697a") +
  labs(title = str_wrap(paste("Mutant proportion per known mutation",
                              "in the gene CYP51"), width = 35),
       subtitle = str_wrap(paste("This gene can mutate and cause resistance to azole fungicides."), width = 65),
       fill = "Proportion of mutants",
       size = "Proportion of mutants",
       x = "Years", y = "")

#Beta_tubulin
genotypes_resistance %>%
  filter(Gene == "beta_tubulin") %>%
  dplyr::count(AA_change, Continent,Sampling_Date, Allele_type) %>%
  pivot_wider(names_from = Allele_type, values_from = n, values_fill = list(n = 0)) %>%
  mutate(Number_all = Mutant + Origin) %>%
  mutate(prop_mutant = Mutant/Number_all) %>%
  group_by(AA_change) %>%
  dplyr::mutate(Somme = sum(Mutant)) %>%
  filter(Somme > 0) %>%
  ggplot(aes(x=Sampling_Date, y=Continent, size = prop_mutant, fill = prop_mutant)) +
  geom_point(shape=21, col = myColors[3], alpha =0.7) + theme_bw() +
  facet_wrap(.~AA_change) + scale_fill_gradient(low="white", high = "#16697a")+
  labs(title = str_wrap(paste("Mutant proportion per known mutation",
                              "in the beta tubuline gene"), width = 35),
       subtitle = str_wrap(paste("This gene can mutate and cause resistance",
                                 " to benzimidazole fungicides."), width = 65),
       fill = "Proportion of mutants",
       size = "Proportion of mutants",
       x = "Years", y = "")

# Mitochondrial_cytb
genotypes_resistance %>%
  filter(Gene == "mitochondrial_cytb") %>%
  dplyr::count(AA_change, Continent,Sampling_Date, Allele_type) %>%
  pivot_wider(names_from = Allele_type, values_from = n, values_fill = list(n = 0)) %>%
  mutate(Number_all = Mutant + Origin) %>%
  mutate(prop_mutant = Mutant/Number_all) %>%
  group_by(AA_change) %>%
  dplyr::mutate(Somme = sum(Mutant)) %>%
  filter(Somme > 0) %>%
  ggplot(aes(x=Sampling_Date, y=Continent, size = prop_mutant, fill = prop_mutant)) +
  geom_point(shape=21, col = myColors[3], alpha =0.7) + theme_bw() +
  facet_wrap(.~AA_change) + scale_fill_gradient(low="white", high = "#16697a") +
  labs(title = str_wrap(paste("Mutant proportion per known mutation",
                              "in the mitochondrial gene cytb"), width = 35),
       subtitle = str_wrap(paste("This gene can mutate and cause resistance ",
                                 "to QoI, or Quinone outside inhibitors."), width = 65),
       fill = "Proportion of mutants",
       size = "Proportion of mutants",
       x = "Years", y = "")


# SDH genes
genotypes_resistance %>%
  filter(grepl("SDH", Gene)) %>%
  unite(Label, Gene, AA_change, remove = T) %>%
  dplyr::count(Label, Continent, Sampling_Date, Allele_type) %>%
  pivot_wider(names_from = Allele_type, values_from = n, values_fill = list(n = 0)) %>%
  mutate(Number_all = Mutant + Origin) %>%
  mutate(prop_mutant = Mutant/Number_all) %>%
  group_by(Label) %>%
  dplyr::mutate(Somme = sum(Mutant)) %>%
  filter(Somme > 0) %>%
  ggplot(aes(x=Sampling_Date, y=Continent, size = prop_mutant, fill = prop_mutant)) +
  geom_point(shape=21, col = myColors[3], alpha =0.7) + theme_bw() +
  facet_wrap(.~Label) + scale_fill_gradient(low="white", high = "#16697a")+
  labs(title = str_wrap(paste("Mutant proportion per known mutation",
                              "in one of the SDH genes"), width = 35),
       subtitle = str_wrap(paste("This gene can mutate and cause resistance to SDHI fungicides."), width = 65),
       fill = "Proportion of mutants",
       size = "Proportion of mutants",
       x = "Years", y = "")
```



<br><br>


# Virulence to new varieties
***

## Thierry Marcel's virulence GWAS
I use the alleles identified in the GWAS of Thierry Marcel and track them in the world-wide populations.
```{r French GWAS Virulence}
virulence_table = read_tsv(paste0(virulence_dir, "French_GWAS_virulence_alleles.tab")) %>%
  separate(VIRULENCE_ALLELES, into = c("VIRULENCE_ALLELE1", "VIRULENCE_ALLELE2"), sep = ",")

french_GWAS_variants = read_tsv(paste0(virulence_dir, "Positions_GWAS.short.vcf"),
                                na = ".")  %>%
  pivot_longer(-c(`#CHROM`, POS, REF, ALT), names_to = "ID_file", values_to = "Allele_nb") %>%
  separate(ALT, into = c("ALT1", "ALT2"), sep = ",") %>%
  mutate(Allele_ID = ifelse(Allele_nb == 0, REF, ifelse(Allele_nb == 1, ALT1, ALT2))) %>%
  left_join(., virulence_table) %>%
  mutate(virulence = ifelse(Allele_ID == NON_VIRULENT_ALLELES, "Non_virulent",
                            ifelse(Allele_ID == VIRULENCE_ALLELE1 | Allele_ID == VIRULENCE_ALLELE2,
                                   "Virulent", NA)))

french_GWAS_variants = inner_join(french_GWAS_variants, Zt_meta)


french_GWAS_variants %>%
  tidyr::unite(position, `#CHROM`, POS) %>%
  dplyr::count(position, Continent,Sampling_Date, virulence) %>%
  pivot_wider(names_from = virulence, values_from = n, values_fill = list(n = 0)) %>%
  mutate(Number_all = Virulent + Non_virulent) %>%
  mutate(prop_virulent = Virulent/Number_all) %>%
  ggplot(aes(x=Sampling_Date, y=Continent, size = prop_virulent, fill = prop_virulent)) +
  geom_point(shape=21, alpha =0.7) + theme_bw() +
  scale_fill_gradient(low="white", high = "#16697a")+
  labs(title = str_wrap(paste("Virulence alleles",
                              ""), width = 35),
       subtitle = str_wrap(paste("These alleles were identified in a GWAS study",
                                 " to increase either virulence or aggressiveness",
                                 " on some wheat varieties."), width = 65),
       fill = "Proportion of virulent",
       size = "Proportion of virulent",
       x = "Years", y = "") +
  facet_wrap(vars(position))

```
Welll... Whatever...

## Avr_Stb6
```{bash, eval = F}
#On the cluster: run blast
while read sample ; do sh Detect_gene_blast.sh ./Directories_new.sh /data2/alice/WW_project/7_Virulence/Avr_Stb6.fasta ${sample} Illumina /data2/alice/WW_project/7_Virulence/${sample}_Avr_Stb6.blast.tab; done < list_Third_batch_Dec_2018.txt

#On the cluster: Gather blast results
cat /data2/alice/WW_project/7_Virulence/*Avr_Stb6.blast.tab > /data2/alice/WW_project/7_Virulence/Overall_results_blast_Avr_Stb6.txt

#On the cluster: Gather blast results
while read p ;
 do
sample=$(echo $p | cut -f 1 -d " " ) ;
 chr=$(echo $p | cut -f 4 -d " ") ;
 start=$(echo $p | cut -f 11 -d " ") ; end=$(echo $p | cut -f 12 -d " ") ;
 echo $sample, $chr, $start, $end ;
 order_start=$(echo -e "$start\n$end"  | sort -n | head -n1);
 order_end=$(echo -e "$start\n$end"  | sort -nr | head -n1);
 echo -e "${chr}\t${order_start}\t${order_end}" > temp.bed ;
 ~/Software/bedtools getfasta \
   -fi /data2/alice/WW_project/4_TE_RIP/1_Blast_from_denovo_assemblies/0_Spades/${sample}.fasta\
   -bed temp.bed | \
   sed "s/>/>${sample}:/" >> \
 /data2/alice/WW_project/7_Virulence/Overall_results_blast_Avr_Stb6.fasta ;
done < /data2/alice/WW_project/7_Virulence/Overall_results_blast_Avr_Stb6.txt

#And on the website, because laziness
mafft --thread 8 --threadtb 5 --threadit 0 --reorder --adjustdirection --auto input > output
```

Here is the tree for the Avr_Stb6 gene. For reference, the allele carried by ST99CH_1A4 gives an avirulent phenotype, while the allele from ST99CH_1A5 is the virulent allele (from [Zhong et al. 2017](https://nph.onlinelibrary.wiley.com/doi/full/10.1111/nph.14434)).

```{r AvrStb6 tree plots}
#grep ">" ../7_Virulence/Overall_results_blast_Avr_Stb6.fasta | sed 's/>//' > ../7_Virulence/Overall_results_blast_Avr_Stb6.list

temp2 = read_tsv(paste0(virulence_dir, "Overall_results_blast_Avr_Stb6.list"), col_names = "Fasta_header") %>%
  separate(Fasta_header, into = c("ID_file", "chr", "coords"), sep=":", remove = F) %>%
  mutate(contig2 = stringr::str_replace_all(Fasta_header, "[:.]", "_")) %>%
  left_join(.,Zt_meta)

#Read tree in
#details from the mafft website about the tree
#Size = 640 sequences × 319 sites
#Method = Neighbor-Joining
#Model = Jukes-Cantor
#Bootstrap resampling = 0
#Alignment id = .200930173318269H5fPcXaMbnDOkoF7E0Y3ilsfnormal


tree_file = "Tree_Avr_Stb6.nwk"
tree = as_tibble(treeio::read.tree(paste0(virulence_dir, tree_file))) %>%
  mutate(label_copy = label) %>%
  separate(label_copy, into = c("nb", "contig"), extra = "merge", remove =F) %>%
  dplyr::mutate(nb = as.integer(nb)) %>%
  dplyr::mutate(label_OG = label) %>%
  dplyr::mutate(contig2 = stringr::str_replace(contig, "R_", "")) %>%
  left_join(., temp2, by = c("contig2")) %>%
  dplyr::mutate(label_temp = ifelse(is.na(ID_file), ifelse(is.na(contig), label, contig), ID_file)) %>%
  unite(col = "label_new", nb, label_temp, sep = "_")

tree2 = as_tibble(treeio::read.tree(paste0(virulence_dir, tree_file)))

temp = tree %>%
  mutate(original_vir = ifelse(ID_file == "ST99CH_1A5", "ST99CH_1A5",
  ifelse(ID_file == "ST99CH_1E4", "ST99CH_1E4", NA))) %>%
  dplyr::select(label, node, label_new, Continent, Sampling_Date, Collection, original_vir) %>%
  filter(!is.na(label))

#Find the outgroup!
root_node = tree2 %>%
  filter(grepl("Zp13", label)) %>%
  dplyr::select(node) %>%
  pull()


rooted.tree <- ape::root(as.treedata(tree2), root_node)
p <- ggtree(rooted.tree, layout = "rectangular") %<+% (temp %>% dplyr::select (-label))

p2 <- p + geom_tippoint(aes(color = Continent), alpha = 0.7) +
  theme(legend.position = "right") +
  Color_Continent

#p2

p3 <- p + geom_tippoint(aes(color = original_vir)) +
  theme(legend.position = "right")  +
  scale_color_manual(values = c(mycolorsCorrel[1], mycolorsCorrel[20]))
cowplot::plot_grid(p2, p3)


p4 <- p + geom_tippoint(aes(color = Sampling_Date), alpha = 0.7) +
  theme(legend.position = "right")
cowplot::plot_grid(p4, p3)
```
